# 数据库存储-diskbased

# 1 从磁盘装载到内存是否使用OS的内存管理机制：大部分数据库不使用

当涉及到数据库存储实现时，仅依赖于操作系统的 mmap 可能并不是最佳选择。以下是一些原因：

* 页面交换的开销：数据库通常需要对数据访问进行优化。如果完全依赖于操作系统的页面交换策略，数据库可能会遭受不必要的页面换入/换出开销。数据库有时可以更好地预测哪些数据将会被访问，因此可以更有效地管理其内存。
* 跨平台一致性：不是所有的操作系统都支持 mmap，或者它们在实现上可能有所不同。依赖于 mmap 可能会让数据库软件的跨平台兼容性变得复杂。
* 写入持久性和原子性：mmap 依赖于操作系统的缓存策略来确定何时将修改的数据写回到磁盘。在某些情况下，这可能会与数据库的持久性和原子性要求相冲突。
* 复杂的缓存管理：大多数数据库有自己的缓存策略和算法，如 LRU。完全依赖于操作系统的缓存管理可能会导致额外的复杂性，特别是在数据库需要细粒度控制的场景中。
* 文件大小限制：当数据库大小增长时，增加文件的大小或管理多个文件可能变得复杂。虽然 mmap 可以处理这些问题，但在某些情况下，使用自定义的存储和内存管理方法可能更简单。
* 故障恢复：在数据库突然崩溃或系统故障的情况下，依赖于 mmap 可能会导致数据恢复更加复杂。

尽管如此，仍然有一些数据库系统或数据存储库使用 mmap 作为它们的存储机制或其部分实现，例如 MongoDB 在某些版本中默认使用 mmap 作为其存储引擎。

总之，数据库的设计考虑了许多复杂的因素，包括数据访问模式、持久性需求、并发性、故障恢复和跨平台兼容性等。因此，选择是否使用 mmap 或其他内存管理策略取决于特定的使用场景和数据库设计目标。

## 2 数据存储形式：file & raw storage with custom filesystem

数据库数据存储一般使用文件（基于OS文件系统），这样兼容性更好，部分早期的数据库系统（特别是类似Oracle的软硬件一体机）会采用裸磁盘存储方式（操作系统无法识别该文件系统）。

存储管理器负责管理多个数据库文件，每个文件中包含多个page。DB中每个page是一个固定大小的块，都有一个唯一的pageID。

> page这个词在不同的场景下可能不同的含义。

> Hardware: block 4KB

> OS：      page  4KB

> database: page  512B-16KB

![](https://raw.githubusercontent.com/yixy4app/images/picgo/202308072255977.png)

## 3 OLTP/OLAP 与 行存储/列存储

### OLTP & OLAP

* OLTP：快速insert、update、delete，需要查询整个tuple的场景。
* OLAP：压缩比高，单个属性的查询和聚合效率高，记录的insert、update、delete较慢。

### 行存储 & 列存储

* 行存储（N-ray storage model/ row store）：一个tuple的所有属性连续的存储在一个page中，适用于OLTP。
* 列存储（column store）：所有tuple的某个属性连续存储在page中

列存储时，可通过offset方式或者内嵌ID方式实现tuple定位。
