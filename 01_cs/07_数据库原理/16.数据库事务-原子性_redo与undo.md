# 数据库事务-原子性:redo与undo

如果不满足 A（Atomicity），则业务的一组操作并没有全部完成。比如写入了订单，但是没有写入订单明细，一定会违反业务的数据完整性。

数据库一般依赖Redo/Undo日志实现事务的原子性。

**下面基本以Oracle实现为模型进行描述，但是redo和undo的基本概念是通用的。**

## 1 什么是redo？什么是undo？

Redo目的是在数据库实例或介质失败时恢复事务。以Oracle为例，通过维护重做日志文件实现这一机制，当数据库发生故障时，我们可以利用这些日志数据重做事务。

Undo的目的是用于撤销和回滚事务。以Oracle为例，undo是oracle在undon段中记录的信息（实际上存储在Oracle的数据文件中，在这个角度看其中数据与表、索引等无本质区别），它主要用于取消或回滚事物。

> undo只是逻辑地恢复到原来的样子，所有修改都被逻辑地取消，但是数据结构以及数据库 块本身在回滚后可能大不相同。比如一个插入操作，新分配了一些数据块。后来事务失败，插入操作全部回滚，新分配的一些数据块还是存在。原因在于：在所有多用户系统中，可能会有数十、数百甚至数千个并发事务。数据库的主要功能之一就是协调对数据的并发访问。也 许我们的事务在修改一些块，而一般来讲往往会有许多其他的事务也在修改这些块。因此，不能简单地将一个块放回到我们的事务开始前的样子，这样会撤销其他事务的工作！

## 2 内存中的数据结构：数据库缓冲区缓存（database buffer cache）与重做日志缓冲区（redo log buffer）

在Oracle中，**数据库缓冲区缓存（database buffer cache）**是数据库内存（Oracle中是SGA）中的一个数据结构，用于临时存储数据库块，利用用内存缓存来缓解块读写IO慢的问题。如果是修改块（更新块上的一行）时，这些修改会在内存中完成，写至数据库缓冲区缓存。同时，会把重做这些修改所需要的足够信息保存在另一个内存数据结构**重做日志缓冲区（redo log buffer）**中。

> 注意，这里没有提到内存中存储undo信息的数据结构，因为在Oracle中，undo段本身与表索引等的存储并无二致，也是存在数据库块中的，所以undo信息本身在内存中也是存储在数据库缓冲区缓存（database buffer cache）。

## 3 redo log的持久化

**重做日志缓冲区（redo log buffer）的内容会持久化写到在线重做日志文件（online redo log file）中**。具体的触发条件如下：

* 按时间频率刷新（比如Oracle，每3s一次）
* 按已使用空间大小（比如Oracle，满三分之一，或者满1MB）
* 任何事务提交一个commit

每个数据库可能有多个在线重做日志文件（online redo log file）组。每个重做日志组都包含一个或多个重做日志成员（redo按成员组来管理）。这些在线重做日志文件的大小是固定的，并以循环方式使用，用于记录数据库中的每个操作。数据库先写日志文件组1，当到达这组文件的最后时，会切换至日志文件组2，从头到尾重写这些文件的内容。日志文件组2填满时，再切换回到日志文件组1（假设只有两个重做日志文件组；如果有3个重做日志文件组，当然会继续写第3个组）。

从一个日志文件组切换到另一个日志文件组的动作称为**日志切换（log switch）**。切换日志文件时就会标记（建立）一个**检查点（checkpointing）**。在每次日志切换之前，数据库需要确认是否到达上一个checkingpoint（确认待覆盖的在线重做日志文件内容对应的数据是否已从数据库缓冲区缓存写入磁盘）。如果数据库判断不满足或者不能肯定这一点，它就会**暂时挂起数据库中的操作，确保将数据库缓冲区缓存（database buffer cache）中的数据（即redo“保护”的数据）安全地写入磁盘本身，然后再建立新的检查点。**一旦数据库检查点校验通过，则恢复处理，并进行日志切换。所以，需要注意到，如果数据库配置得不好，日志切换可能会导致临时性“暂停”。

**归档重做日志（Archive redo log file）**：大多数数据库可以采用两种模式运行，即ARCHIVELOG模式和NOARCHIVELOG模式。这两种模式的区别只有一点，即Oracle日志切换时是否会保留将被覆盖的redo log的一个副本。

> “我们在使用RAID-5，并不意味着可以得到完全的保护”：由于制造方面的错误，过有时硬件控制器会对数据文件带来破坏，此时RAID设备只是安全地保护已经被破坏的数据。另外，对于避免操作员错误（这也是丢失数据的一个最常见的原因），RAID也无能为力。

## 4 数据库缓冲区缓存持久化

数据库缓冲区缓存写入磁盘，一般是为了在缓存中腾出更多的空间（释放缓冲区来读入其他数据），或者是为了推进检查点。

## 5 理解事务提交-commit

执行commit之前的阶段，已经发生了如下操作：

* 在内存数据结构中生成undo块
* 修改更新数据库缓冲区缓存（database buffer cache）中的数据块
* 重做日志缓冲区（redo log buffer）中生成了前两项的缓存redo
* 取决于前三项的大小以及这些工作花费的时间，前面的某个数据（或某些数据）可能已经刷新输出到磁盘。
* 已经取得了所需的全部锁。

执行commit时，剩余的工作如下：

* 为事务生成一个SCN。SCN是Oracle使用的一种简单的计时机制，用于保证事务的顺序，并支持失败恢复。SCN还用于保证数据库中的读一致性和检查点。可以把SCN看作一个钟摆，每次有人COMMIT时，SCN都会增1.
*  将所有余下的缓存重做日志条目写到磁盘，并把SCN记录到在线重做日志文件中。这一步就是真正的COMMIT。如果出现了这一步，即已经提交。
* 会话持有的锁都将被释放，而排队等待这些锁的每一个人都会被唤醒，可以继续完成他们的工作。
* 如果事务修改的某些块还在缓冲区缓存中，则会以一种快速的模式访问并“清理”。块清除（Block cleanout）是指清除存储在数据库块首部的与锁相关的信息。实质上讲，我们在清除块上的事务信息，这样下一个访问这个块的人就不用再这么做了。我们采用一种无需生成重做日志信息的方式来完成块清除，这样可以省去以后的大量工作（在下面的“块清除”一节中将更全面地讨论这个问题）。（实际上，理解为“块清理”更贴切。

COMMIT的响应时间与事务大小无关，在数据库中执行COMMIT之前，困难的工作都已经做了。我们已经修改了数据库中的数据，所以99.9%的工作都已经完成。可以看到，处理COMMIT所要做的工作很少。其中耗时最长的操作要算“将所有余下的缓存重做日志条目写到磁盘”，因为这些磁盘写是物理磁盘I/O。不过，这里花费的时间并不会太多，之所以能大幅减少这个操作的时间，原因是数据库一直在以连续的方式刷新输出重做日志缓冲区的内容。这样做是为了避免COMMIT等待很长时间来一次性刷新输出所有的redo。

## 6 理解事务回滚-rollback

执行rollback之前的阶段，已经发生了如下操作：

* 在内存数据结构中生成undo块
* 修改更新数据库缓冲区缓存（database buffer cache）中的数据块
* 重做日志缓冲区（redo log buffer）中生成了前两项的缓存redo
* 取决于前三项的大小以及这些工作花费的时间，前面的某个数据（或某些数据）可能已经刷新输出到磁盘。
* 已经取得了所需的全部锁。

执行rollback时，剩余的工作如下：

* 撤销已做的所有修改。其完成方式如下：从undo段读回数据，然后实际上逆向执行前面所做的操作，并将undo条目标记为已用。如果先前插入了一行，ROLLBACK会将其删除。如果更新了一行，回滚就会取消更新。如果删除了一行，回滚将把它再次插入。
* 会话持有的所有锁都将释放，如果有人在排队等待我们持有的锁，就会被唤醒。

与ROLLBACK相比，COMMIT完成的工作非常少。这里的关键是，除非不得已，否则不会希望回滚。回滚操作的开销很大，因为你花了大量的时间做工作，还要花大量的时间撤销这些工作。除非你有把握肯定会COMMIT你的工作，否则干脆什么也别做。

一般来讲，INSERT生成的undo最少，因为Oracle为此需记录的只是要“删除”的一个rowid（行ID）。UPDATE一般排名第二（在大多数情况下）。对于UPDATE，只需记录修改的字节。你可能只更新（UPDATE）了整个数据行中很少的一部分，这种情况最常见。因此，必须在undo中记录行的一小部分。前面的许多例子都与这条经验相左，不过这是因为那些列更新的行很大（有固定大小），而且它们更新了整个行。更常见的是UPDATE一行，并修改整行中的一小部分。一般来讲，DELETE生成的undo最多。对于DELETE，Oracle必须把整行的前映像记录到undo段中。在redo生成方面，前面的临时表例子展示了这样一个事实：DELETE生成的redo最多，而且由于临时表的DML操作只会把undo记入日志，这实际上也表明DELETE会生成最多的undo。INSERT只生成需要建立日志的很少的undo。UPDATE生成的undo量等于所修改数据的前映像大小，DELETE会生成整个数据集写至undo段。前面已经提到，必须把索引执行的工作也考虑在内。你会发现，与加索引列的更新相比，对一个未加索引的列进行更新不仅执行得更快，生成的undo也会好得多。
