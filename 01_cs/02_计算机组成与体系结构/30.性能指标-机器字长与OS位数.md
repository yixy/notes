# 性能指标-机器字长与OS位数

**字**通常指字节或位的有序组合，是在计算机系统中存储、传送和操作的正常信息单位。

## 1 机器字长=处理器位数=数据总线位数 ##

**CPU位数（处理器位数）**是指CPU能一次（一个时钟周期内）同时寄存和处理二进制数码的位数，这和CPU中寄存器位数或CPU内部数据总线带宽相同。

**数据总线位数**指数据总线一次能并行传送的位数。

> 存储字长：一个存储单元存储二进制的长度。一般为字节的整数倍。存储字长一般都是8字节。
> 指令字长：一个指令中包含二进制代码的位数。一般取存储字长的整数倍。

**机器字长**的含义是数据通路的宽度。数据通路是指CPU内部数据流经的路径以及路径上的部件（比如数据总线，寄存器），这些部件的宽度要一致，才能匹配。机器字长由CPU位数和数据总线带宽共同决定，两者通常情况下是相同的。所以，我们通常也说处理器位数或数据总线宽度是衡量微处理器的标准。

**一般地，机器字长=CPU位数=CPU内部寄存器的宽度=CPU内部总线宽度=数据总线的宽度。**

一般处理器多少位是指通用寄存器的长度，当然数据线一般与之相同；地址线则不需要与之相等，好比 intel 64 位处理器则是 40 位地址总线，最大支持 1TB 的内存寻址。

## 2 操作系统位数：32bit/64bit ##

操作系统的位数主要指的是操作系统用于处理数据和内存地址的字长。操作系统的位数通常与其运行的硬件（特别是CPU）的位数匹配。

###### 32位和64位系统 ######

操作系统同样可分为32位与64位。在x86_64架构的CPU出现之前，PC的操作系统都是用32位，例如windows 2000，xp，当时的unix，linux等。在x86_64架构出现后，系统也就有了两个版本:32位和64位，两者的主要区别在于与硬件体系结构相关的操作中。由于x86_64架构完全兼容x86架构，因此，32位的系统完全可以在x86_64位上运行，只不过它只使用了x86部分，没有完全发挥硬件的功能而已。而64位系统专门针对64位的扩展功能而开发的，就是为了最大限度地发挥硬件的能力，它无法在x86架构的cpu上运行。

另外，不论是windows还是linux，驱动程序都需要加载到内核空间中，因此它的类型(32位或64位）需要跟系统完全相同。

系统与CPU的关系如下图所示：

![](https://raw.githubusercontent.com/yixy4app/images/picgo/202208272121185.jpg)

###### 操作系统的逻辑寻址空间:操作系统的位数对逻辑寻址空间（虚拟地址空间）的大小有重要影响。 ######

如对于32位的操作系统而言，其逻辑地址编码采用的地址位数是32位，那么操作系统所提供的逻辑地址寻址范围为：2^32 =4GB（所以在32位CPU和32位的操作系统中，最大支持的内存为4G）。但是理论上是4G的内存，在我们真正使用时并不到4G，大约只有3.2G左右。这是因为在intel x86架构下，采用的是内存映射技术(Memory-Mapped I/O, MMIO)，也就说将4GB逻辑地址中一部分要划分出来与BIOS ROM、CPU寄存器、I/O设备这些部件的物理地址进行映射，那么逻辑地址中能够与内存条的物理地址进行映射的空间肯定没有4GB了。

64位的操作系统，其逻辑地址编码采用的地址位数是64位，最大寻址内存理论上为2^64B。但实际上，以Linux为例，128TiB(2^47)内核空间，128TiB(2^47)用户空间，并没有占满2^64的上限。（补充一下，在APUE第1.11 中提到，针对64位体系结构每个进程内部可以使用更长都编址长度，即64位指针）。

另外，注意以上讨论的是操作系统逻辑地址空间。实际上，自从64位CPU出现之后，一次便能够处理64位的数据，但其地址总线一般采用的是36位或者40位（即CPU能够寻址的物理地址空间为64GB或者1T）。

