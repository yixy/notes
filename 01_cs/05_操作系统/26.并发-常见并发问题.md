# 并发-插叙:常见并发问题

研究集中在 4 个重要的开源应用:MySQL(流行的数据库管理系统) 、Apache(著名的Web 服务器) 、Mozilla(著名的 Web 浏览器)和 OpenOffice(微软办公套件的开源版本) 。研究人员通过检查这几个代码库已修复的并发缺陷,将开发者的工作变成量化的缺陷分析。理解这些结果,有助于我们了解在成熟的代码库中,实际出现过哪些类型的并发问题。从研究结论可以看出,共统计 105 个缺陷,其中大多数是非死锁相关的(74 个) ,剩余 31 个是死锁缺陷。

不难看出，**非死锁问题占了并发问题的大多数**。

## 1 非死锁的缺陷 ##

**非死锁问题主要包括两种:违反原子性(atomicity violation)缺陷和错误顺序(order violation)缺陷。**大部分(97%)的非死锁问题是违反原子性和违反顺序这两种。因此,程序员仔细研究这些错误模式,应该能够更好地避免它们。此外,随着更自动化的代码检查工具的发展,它们也应该关注这两种错误,因为开发中发现的非死锁问题大部分都是这两种。

## 2 死锁缺陷 ##

**死锁(deadlock)**是一种在许多复杂并发系统中出现的经典问题。例如,当线程 1 持有锁 L1,正在等待另外一个锁 L2,而线程 2 持有锁 L2,却在等待锁 L1 释放时,死锁就产生了。

死锁的产生需要如下 4 个条件：

* 互斥:线程对于需要的资源进行互斥的访问(例如一个线程抢到锁)。 
* 持有并等待:线程持有了资源(例如已将持有的锁),同时又在等待其他资源(例如,需要获得的锁)。 
* 非抢占:线程获得的资源(例如锁),不能被抢占。 
* 循环等待:线程之间存在一个环路,环路上每个线程都额外持有一个资源,而这个资源又是下一个线程要申请的。 

如果这 4 个条件的任何一个没有满足,死锁就不会产生。

###### 死锁的解决方案 ######

* 死锁预防：通过每个策略都设法阻止某一个条件,从而解决死锁的问题。
* 死锁避免(avoidance)：需要了解全局的信息,包括不同线程在运行中对锁的需求情况,从而使得后续的调度能够避免产生死锁。
* 检查和恢复：最后一种常用的策略就是允许死锁偶尔发生,检查到死锁时再采取行动。
