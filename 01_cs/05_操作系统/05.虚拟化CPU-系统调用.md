# 虚拟化CPU-系统调用

问题：一个进程必须能够执行 I/O 和其他一些受限制的操作，但又不能让进程完全控制系统。操作系统和硬件如何协作实现这一点？

## 1 用户态和内核态 ##

硬件通过提供不同的执行模式来协助操作系统。在 **用户模式(user mode)** 下，应用程序不能完全访问硬件资源，并且不能直接饮用地址空间中内核区的代码和数据。在 **内核模式(kernel mode)** 下，则没有这个限制，例如操作系统可以访问机器的全部资源。基于此，在用户模式下运行的代码会受到限制。例如，在用户模式下运行时，进程不能发出 I/O 请求。这样做会导致处理器引发异常，操作系统可能会终止进程。与用户模式不同的内核模式(kernel mode) ，操作系统(或内核)就以这种模式运行。在此模式下，运行的代码可以做它喜欢的事，包括特权操作，如发出 I/O 请求和执行所有类型的受限指令。

以Intel x86CPU为例，它提供了保护模式，保护模式支持四个级别，0-3 级，0 级特权级最高，3 级特权级最低。Linux操作系统使用0作为内核态，3作为用户态。

需注意，内核模式和用户模式这两种进程状态是CPU提供的控制，而不是操作系统提供的。在CPU中一个称为PSW（program status word，程序状态字）的寄存器中保存了和进程有关的一些控制位，例如内核模式和用户模式的进程状态。

## 2 系统调用与trap ##

但是， 我们仍然面临着一个挑战——如果用户希望执行某种特权操作 (如从磁盘读取) ， 应该怎么做？为了实现这一点，几乎所有的现代硬件都提供了用户程序执行系统调用的能力。

**系统调用（System Call）中包含特殊的陷阱(trap)指令**。trap指令执行时会跳入操作系统内核代码，并将特权级别提升到内核模式。 一旦进入内核， 系统就可以执行陷阱处理程序（具体可参考下节关于异常的讨论）， 从而为调用进程执行所需的工作。完成后，操作系统调用一个特殊的**陷阱返回(return-from-trap)指令**，如你期望的那样，该指令返回到发起调用的用户程序中，同时将特权级别降低，回到用户模式。 

执行陷阱时，硬件需要小心，因为它必须确保存储足够的调用者寄存器，以便在操作系统发出从陷阱返回指令时能够正确返回。例如，在 x86 上，处理器会将程序计数器、标志和其他一些寄存器推送到每个进程的内核栈(kernel stack)上。从返回陷阱将从栈弹出这些值，并恢复执行用户模式程序(有关详细信息，请参阅英特尔系统手册) 。其他硬件系统使用不同的约定，但基本概念在各个平台上是相似的。

另外，系统调用通过 **异常表（exception table）** 来确认应该在操作系统内运行哪些对应的代码（中断执行例程）。

> 中断和陷阱的讨论见异常相关章节。

**为什么系统调用看起来像过程调用？**

原因很简单:它是一个过程调用，但隐藏在过程调用内部的是著名的陷阱指令（早期采用的是INT 80H中断的方式处理系统调用，intel后来推出了SYSCALL/SYSENTER/SYSEXIT指令）。更具体地说，当你调用 open() (举个例子)时，你正在执行对 C 库的过程调用。其中，无论是对于 open()还是提供的其他系统调用，库都使用与内核一致的调用约定来将参数放在众所周知的位置(例如，在栈中或特定的寄存器中) ，将系统调用号也放入一个众所周知的位置(同样，放在栈或寄存器中) ，然后执行上述的陷阱指令。库中陷阱之后的代码准备好返回值，并将控制权返回给发出系统调用的程序。因此，C 库中进行系统调用的部分是用汇编手工编码的，因为它们需要仔细遵循约定，以便正确处理参数和返回值，以及执行硬件特定的陷阱指令。现在你知道为什么你自己不必写汇编代码来陷入操作系统了，因为有人已经为你写了这些汇编。

## 3 系统调用的过程：进程用户栈和内核栈的切换

当进程因为中断或者系统调用而陷入内核态之行时，进程所使用的堆栈也要从用户栈转到内核栈。中断和系统调用的过程是类似的，下面以中断过程为例：

> 实际实现中，不同OS可能采用不同的策略。比如Linux并不是把所有的寄存器都存储在内核栈中的，它还使用了其它数据结构。但在此次不作详细讨论了，简单起见，我们认为CPU寄存器状态都存储在内核栈中。

1. 进程陷入内核态后，先把用户态堆栈的地址（SS与SP）保存在内核栈之中，随后设置堆栈指针寄存器的内容为内核栈的地址，这样就完成了用户栈向内核栈的转换；
2. 将PSW和程序计数器（CS与IP）压入内核栈，设置程序计数器指向中断执行例程；
3. 中断执行例程执行时首先将所有其它CPU寄存器压入内核栈；
4. 继续执行中断例程中的剩余逻辑；
5. 中断执行例程返回前将被调度进程内核栈中之前压入的相关寄存器恢复
6. 最终，在进程从内核态恢复到用户态前，在内核态执行的最后依次将保存在内核栈里面的程序计数器、PSW和用户栈的地址恢复到相关寄存器即可。这样就实现了内核栈和用户栈的互转。

下图为中断发生时，执行中断例程前。

![](https://raw.githubusercontent.com/yixy4app/images/picgo/202209082218631.png)

下图为执行中断例程后。

![](https://raw.githubusercontent.com/yixy4app/images/picgo/202209082218820.png)

> 注意，从内核转到用户态时用户栈的地址是在陷入内核的时候保存在内核栈里面的，但是在陷入内核的时候，我们是如何知道内核栈的地址的呢？关键在进程从用户态转到内核态的时候，进程的内核栈总是空的。这是因为，当进程在用户态运行时，使用的是用户栈，当进程陷入到内核态时，内核栈保存进程在内核态运行的相关信息，但是一旦进程返回到用户态后，内核栈中保存的信息无效，会全部恢复，因此每次进程从用户态陷入内核的时候得到的内核栈都是空的。所以在进程陷入内核的时候，直接把内核栈的栈顶地址给堆栈指针寄存器就可以了。

> 栈帧中保存了传递给该函数的参数、该函数中定义的局部变量、函数的返回值、调用该函数的程序计数器副本，以及一些其它重要信息。

