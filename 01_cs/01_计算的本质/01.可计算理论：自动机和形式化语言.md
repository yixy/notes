# 可计算理论：自动机和形式化语言

## 1 自动机理论和形式化语言

希尔伯特是著名的数学家，他在20世纪初提出了一组未解的数学问题，被称为“希尔伯特的23个问题”。其中的第十个问题就涉及到自动机理论和形式化语言理论的发展。自动机理论、形式化语言理论以及希尔伯特的假设，都是可计算性理论的核心组成部分。它们以不同的方式揭示了哪些问题可以通过计算来解决，以及哪些问题无法通过计算解决。

1、自动机理论：这个理论为研究计算机如何解决问题提供了一个基本框架。特别是图灵机模型，为我们理解什么是“可计算的”提供了一个标准。如果一个问题可以由图灵机在有限的步骤内解决，那么我们就称这个问题是可计算的。

2、形式化语言理论：研究语言语法的数学和计算机科学分支叫做形式语言理论，它不致力于语言的语义研究。乔姆斯基证明了形式语言与自动机的等价性。形式化语言是计算机和人类交流的基础，同时也是计算机程序的基础。形式化语言理论帮助我们理解哪些问题可以被形式化描述，并由计算机执行。

3、希尔伯特的假设：希尔伯特的第十个问题，也就是二次丢番图方程的解决性问题，引领了对于哪些问题是可计算的，哪些问题是不可计算的深入研究。这一问题的解答（不存在一个通用的算法来解决所有的二次丢番图方程）首次证明了存在不可计算的问题，这直接影响了我们对可计算性的理解。

因此，这三个主题都与可计算性理论密切相关，他们一起帮助我们理解了哪些问题可以通过算法或计算机解决，哪些问题无法解决，以及如何描述和处理这些问题。

> 在计算机科学和语言学中，乔姆斯基文法（Chomsky Grammar）被划分为四种类型，从0型到3型。这四种类型的文法从0到3，限制越来越强，因此能够描述的语言的范围也越来越小，但同时它们的解析效率也越来越高。这种分类的本质是反映了文法的生成能力和解析复杂性。类型越低，文法的生成能力越强，解析的复杂性越高；类型越高，文法的生成能力越弱，但是解析的效率越高。在实际应用中，如编译器的设计，通常会使用2型文法（上下文无关文法），因为它的表达能力和解析效率之间达到了很好的平衡。

### 图灵机与计算机的关系

今天的电子计算机，都是**图灵机**的实例，都建立在**冯诺依曼体系结构**之上，都由若干**布尔电路**电子器件组合而成。

* 系统基础：冯诺依曼体系结构
* 物理基础：数字电路
* 数学基础：图灵机

## 2 DFA&NFA：正则语言

* DFA：确定性有限状态自动机没有额外的存储空间，通过硬编码逻辑实现有限个状态的规则的集合，以决定在相应的输入下如何从一个状态切换到另一个状态。这些规则要求对每一个状态和输入的组合，有且仅有一个规则。DFA只能接受（判断复合规则）最简单的正则语言。
* NFA：非确定性有限状态自动机在DFA的基础上，对规则进行适当放宽：1）不确定性：NFA在向下一个状态转移时可能有多种选择，或者根本无法转移；2）自由转移：NFA的状态无需读取任何输入就能自发的进行状态转移。
* DFA和NFA的等价性：非确定性和自由转移的适当放宽实际上并不能提升有限状态机的处理能力。NFA可以看成是从某个状态集移动到另一个状态集，这本身是确定的。NFA可以转换为DFA，通过最小化DFA可以更方便的实现DFA。

* 3型文法（正则表达-Finite state automaton，对应DFA和NFA）：产生式的左边必须只有一个非终结符，右边必须是一个终结符后跟一个非终结符，或者只有一个终结符。

>它是在2型文法的基础上满足:A→α|αB（右线性）或A→α|Bα（左线性）。注意一个语法中，只能选择右线性或左线性的一个规则（A regular grammar is a left or right regular grammar）。

## 3 DPDA：任意嵌套平衡字符串 & NPDA：回文（上下文无关语言）

* DPDA：确定性下推自动机在DFA的基础上，提供一个后进先出的存储空间（栈）。注意，实际上栈大小肯定是有限的，但在思维实验中可以根据需要让他尽可能的大（无限大）。针对栈的规则：1）针对每个输入，每个规则声明栈必须pop；2）规则需要指明pop后需要push入栈的字符序列（三种情况：空、pop字符+指定字符、指定字符）。PDA可以识别任意嵌套级别的平衡字符串（考虑括号匹配的问题）。
* NPDA：非确定性下推自动机在DPDA的基础上，放宽确定性约束：给定当前状态和栈顶符号，NPDA可能有多种可能的转移状态和动作。NPDA可以接受所有的上下文无关语言，可以识别类似babbaabbab的回文字符串（DPDA不能识别回文，只能识别在中间插入标记m的字符串babbamabbab）。

> 对于DPDA，对于给定的当前状态和栈顶符号，只有一种可能的转移状态和动作。这意味着DPDA的行为在每个步骤上都是确定的，没有歧义。因此，DPDA可以在没有回溯的情况下运行。而NPDA的行为在每个步骤上都是非确定的，可能有多个有效的路径可以选择。为了处理这种非确定性，NPDA的实现通常涉及一种形式的回溯，即尝试所有可能的路径，并在找到接受状态的路径时停止。在实际应用中，这种非确定性通常是通过搜索算法来实现的，如深度优先搜索或广度优先搜索。这样的搜索算法会探索所有可能的状态转移路径，直到找到一个导致接受状态的路径为止。需要注意的是，虽然NPDA在理论上比DPDA更为强大（它可以接受更多的语言类型），但在实际应用中，如编译器设计等，我们通常会使用DPDA，因为非确定性计算在实践中是很难实现且效率低下的。

> 深度优先搜索 (DFS) 通常在实现非确定性下推自动机 (NPDA) 时用来探索所有可能的状态转移路径。然而，由于DFS是一种递归算法，它需要额外的存储空间来存储路径信息，以及跟踪访问过的节点和待访问的节点。具体到NPDA，DFS需要维护一个堆栈来存储正在探索的路径中的每个状态和相关的栈状态。这些信息将在回溯期间使用，因此它确实需要额外的存储空间。但需要注意的是，虽然DFS需要额外的存储空间，但与需要存储所有可能的路径的算法（如广度优先搜索）相比，它的存储需求通常更小。这是因为DFS每次只在堆栈中存储从根节点到当前节点的路径，而不是所有可能的路径。尽管如此，DFS可能会在某些情况下，特别是在搜索深度非常大的情况下，占用大量的存储空间。

注意，DPDA和NPDA不等价！！！

* 2型文法（上下文无关文法-Non-deterministic pushdown automaton，对应NPDA）：产生式左边只有一个非终结符，右边可以是任意长度的字符串。

```
//上下文无关文法：只要找到符合产生式右边的串，就可以把它归约为对应的非终结符。
S -> aSb
S -> ab
```

在编译原理中，上下文无关文法（2型文法）最为常用，因为它提供了一个很好的平衡点。对于大多数编程语言，上下文无关文法就足够描述其语法结构，同时又不至于像1型和0型文法那样过于复杂难以处理。另外，上下文无关文法可以使用相对简单的解析算法进行解析，使得编译器的实现相对容易，同时能够保证编译过程的效率。

## 4 线性有界非确定性图灵机：上下文有关文法

* 线性有界非确定型图灵机的存储空间受到输入大小的限制，可以处理所有的上下文相关语言。

* 1型文法（上下文有关文法-Linear-bounded non-deterministic Turing machine）：产生式的左边可以是任意长度的字符串，但右边的长度必须不小于左边。

```
//上下文相关文法：因为它的第一个产生式左边有不止一个符号，所以在匹配这个产生式中的S的时候必需确保这个S有正确的“上下文”，也就是左边的a和右边的b，所以叫上下文相关文法。
aSb -> aaSbb
S -> ab
```

## 5 图灵机TM：可计算

怎么才能设计一台能实际运行程序而不总是执行某个硬编码任务的机器呢？

### 确定性图灵机和非确定性图灵机是等价的

* 图灵机：能访问一条无限长纸带的有限状态自动机叫做图灵机。

图灵的做法是给一台机器配上一条无限长的空纸带（实际上是一个两端都能随需增长的一维数组） ，并且允许在纸带上的任意位置读写字符。一条纸带既做存储又做输入：可以在纸带上预先填满字符串当作输入，然后机器在执行过程中可以读取这些字符并在必要的时候覆盖它们。

> 传统的图灵机使用简单的安排：用一个纸带头（tape head）指向纸带的一个特定位置，并且只能在那个位置读取或写入字符。每一步计算之后，纸带头都可以向左或者向右移动一个方格，这意味着一台图灵机为了到达远处的位置只能费力地在纸带上往复移动。使用移动缓慢的纸带头不会影响机器访问纸带上任何数据的能力，只会影响花费的时间，因此为了保持简单付出这个代价是值得的。

* 确定性TM和非确定型TM是等价的：图灵机的一条纸带能用来存储多条纸带的内容，一台确定型图灵机可以模拟一台非确定型图灵机，这意味着不能仅仅通过增加非确定性就能让一台图灵机更强大。

### 通用图灵机： 可以解决任何可计算性问题

* 通用图灵机：我们能设计一合图灵机，它能通过从纸带读取其规则、接受状态以及起始配置然后单步执行，模拟任何其他确定型图灵机，本质上这扮演着图灵机规则手册解释器的角色。完成这种工作的机器明作通用图灵机 (Universal Turing Machine, UTM)。

通用图灵机代表了从有限计算机器到全能机器的临界点。实际上，通过升级图灵机规范以使其更强大的任何尝试都注定失败，因为它们本来就有能力模拟任何潜在的增强了。尽管增加某些特性会使图灵机更小巧或者更高效，但无法从根本上增强它们的能力。

* 邱奇图灵论题（Church–Turing thesis）：任何算法都能被一台机器（特别是一台确定型的图灵机）执行 。尽管这仅仅是一个猜想而不是一个被证明的事实，但有足够的证据让它成为广泛接受的真理。

* 问题的可判定/可计算性：如果存在一个算法，对任何可能的输人都能保证在有限时间内解決一个判定性问题，那么这个问题就是可判定的（或者叫可计算的)。邱奇一图灵论题认为每一个算法都能由图灵机执行，所以对于一个可判定性的问题，我们可以设计一台总是产生正确答案的图灵机，并且如果运行足够长的时间，它总是能停机。

当我们说一个问题是“可计算的”，我们是指存在一个算法，这个算法满足以下的特性：

1. 有穷性：算法必须在有限的步骤之后停止。这也是“可计算”中“有限”的含义。
2. 确定性：每一步操作都应该是明确的，没有模棱两可的地方。
3. 可行性：每一步都必须足够简单，能在有限的时间内完成。
4. 输入：算法有零个或多个明确定义的输入。
5. 输出：算法产生一个或多个明确的输出，并且这些输出是问题的解。

当一个问题存在满足上述所有特性的算法时，我们说这个问题是可计算的，意味着理论上图灵机可以解决这个问题。需要注意的是，即使问题是可计算的，具体实施的时候还需要考虑计算资源（如时间、空间）的限制，有些问题尽管在理论上可计算，但因为涉及的计算量过大，实际上可能难以解决。

**所以，通常可以理解为通用图灵机的最大能力是可以处理任何的计算问题（如果该问题是可计算的）。任何现实世界中的计算机或者编程语言只能做到与图灵机做的一样多的事，不能再多了。是否最终有可能构建一台比图灵机更强大的机器——能使用外来的物理法则执行超越我们对“算法”想象的任务——现在还不能确切知道，但可以肯定的是我们现在不知道如何做。**

尽管图灵机在理论上被认为能解决所有可计算问题，但实际中存在很多因素如计算资源限制（例如时间和空间）使得有些问题在实践中难以解决。因此，研发更高效的算法和机器对于解决实际问题是非常重要的。

我们都可以通过提出大量算法并观察我们选择的计算系统（图灵机、lambda 演算、部分递归函数，或者 Ruby）是否能够实现它们来收集证据。数学家和计算机科学家差不多从 20 世纪 30 年代开始就已经在这么做了，但到目前为止还没有人成功设计出这些系统不能执行的算法。因此我们可以对经验上的直觉相当自信：一台机器肯定能执行任何算法。另一个比较强的证据是这些系统中大多数都是为了尝试捕捉和分析一个算法的非形式化思想而独立发展的，只是后来才被发现彼此之间恰好等价。每一次对算法思想的建模尝试都产生了一个系统，这个系统的能力与一台图灵机的能力等价，而这是对一台图灵机足够表示一个算法的很好暗示。

不管怎样，它都叫“邱奇 - 图灵论题” ，而不是“邱奇 - 图灵定理” 。因为它是一个非形式化的断言而不是一个可证明的数学断言——它没法用纯数学化的语言表达，因此没有办法构建数学证明。因为它与我们对计算本质的直觉判断和算法能做事情的证据相符，所以被广泛认为是真的，但我们仍旧称它为“论题” ，以便提醒自己它的状态与毕达哥拉斯定理这样的可证明思想不同。

图灵机可以接受0型文法。

* 0型文法（无限制文法或短语结构文法-Turing machine）：产生式的左边可以是任意长度的字符串，右边也可以是任意长度的字符串。也就是说，它几乎没有限制，可以用于描述所有的形式语言。

### 停机问题

计算能做的事情是有限制的。我们不知道如何构建比图灵机能力更强的机器，但确实存在图灵机无法解决的问题。大量的非判定性问题是关于机器和程序执行过程中的行为的。这其中最著名的就是停机问題，停机问题要解决的是对拥有一条特定纸带的特定图灵机判定它的执行是否能够停机。

艾伦·图灵证明了停机问题是不可解的，意味着不存在一个算法可以解决所有情况的停机问题。他的证明方法是通过反证法：假设存在这样的算法，然后通过一系列的逻辑推理，导致矛盾，从而得出不存在这样的算法。

他假设存在一个程序H，可以判断任何程序P对于任何输入I是否停机。然后他构造了一个新的程序D，这个程序会读取输入并模仿其行为，但是反向行动，如果H认为P会停机，D就让自己进入无限循环，否则停止。接着他把D作为输入喂给自己，这时候就出现了矛盾：如果D停机，那就意味着D应该进入无限循环，反之亦然。所以，不存在一个程序H可以解决所有情况的停机问题。
