# 网络编程(9.2)——捕获SIGCHLD信号 #

## 1. 即发即弃与看顾 ##

如果父进程对子进程采用即发即弃的策略，那么可能导致系统中出现僵尸进程。大量僵尸进程会占用内核空间，最终导致耗尽系统资源。所以父进程中需要捕获子进程的SIGCHLD信号，实现对子进程的看顾。

## 2. 使用waitpid函数而不是wait函数 ##

函数wait和waitpid均返回两个值：已终止进程的进程ID。

```
#include <sys/wait.h>
pid_t wait(int *status);
pit_t waitpid(pid_t pid,int *status,int options);
```

如果调用wait的进程没有已终止的子进程，不过有一个或多个子进程仍在执行，那么wait将阻塞到现有子进程中第一个子进程终止为止。

与wait函数相比，waitpid函数就等待哪个进程以及是否阻塞给了调用者更多的控制。首先，pid参数允许指定等待的进程ID，值-1表示等待第一个终止的子进程。其次，options参数允许我们指定附加选项。最常用的选项是WNOHANG，它告知内核在没有已终止子进程时不要阻塞。

建立一个信号处理函数并在其中调用wait并不足以防止出现僵尸进程。

考虑这样一个例子，多客户端在同一时刻终止连接的场景。这将导致服务器端端5个子进程差不多同一时刻终止，这又导致在差不多同一时刻有5个SIGCHLD信号递交给服务器端父进程。如果所有5个信号都在信号处理函数执行之前产生，而Unix信号一般是不排队的，所以信号处理函数只执行一次，此时会产生4个僵尸进程。更严重的是，本问题是不确定的，信号处理函数的执行次数取决于具体的时序。

正确的解决方法是在循环内调用waitpid，以获取所有已终止子进程的状态。并且必须指定WHOHANG选项，告知waitpid在有尚未终止的子进程在运行时不要阻塞。注意，这里不能使用wait，因为没有办法防止wait在正在运行的子进程尚有未终止时阻塞。