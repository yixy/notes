# 持久化-文件系统

**注意，register和cache的管理都由硬件来完成，换句话说，register/cache同内存之间的数据交换对所有程序员都是透明的；内存的管理由硬件和操作系统来完成，即内存同磁盘、光盘、磁带等低速设备之间的数据交换对应用程序员是透明的；磁盘等低速非易失性存储器的管理则被抽象称为文件进行管理，文件模型对应用程序员来说是可见的。**

## 1. 文件和目录 ##

**文件** 就是 一个线性字节数组，每个字节都可以读取或写入。每个文件都有某种低级名称(low-level name)，通常是某种数字。用户通常不知道这个名字。由于历史原因， 文件的低级名称通常称为 inode 号(inode number)。每个文件都有一个与其关联的 inode 号。

文件可以有多种构造方式，常见的一种文件结构实现是采用无结构的字节序列，OS实际上不知道也不关心文件的内容是什么，OS所见到的就是字节，其任何含义只在用户程序中解释。在Unix和Windows中都采用这种方法。

**目录** 像一个文件一样，也有一个低级名字(即 inode 号)，但是它的内容非常具体:它包含一个(用户可读名字，低级名字)对的列表。例 如，假设存在一个低级别名称为“10”的文件，它的用户可读的名称为“foo”。“foo”所在 的目录因此会有条目(“foo”，“10”)，将用户可读名称映射到低级名称。目录中的每个条目 都指向文件或其他目录。通过将目录放入其他目录中，用户可以构建任意的目录树(directory tree，或目录层次结构，directory hierarchy)，在该目录树下存储所有文件和目录。

文件可读名称的命名规则在各个OS中不尽相同。需要注意的一点是，Unix-like文件系统是区分大小写的，MS-DOS则是不区分大小写的。

大多数OS使用目录树来组织文件系统，此时需要某种方法指明文件。常用的方法有两种。

* 绝对路径：从根目录到文件的路径组成。
* 相对路径：相对于当前进程工作目录的一个路径。

## 2. 文件系统接口-API ##

创建一个文件。这可以通过 open 系统调用完成。通过调 用 open()并传入 O_CREAT 标志，程序可以创建一个新文件。open()的一个重要方面是它的返回值:文件描述符(file descriptor)。文件描述符只是一 个整数，是每个进程私有的，在 UNIX 系统中用于访问文件。因此，一旦文件被打开，你 就可以使用文件描述符来读取或写入文件，假定你有权这样做。这样，一个文件描述符就 是一种权限(capability)，即一个不透明的句柄，它可以让你执行某些操作。另一种 看待文件描述符的方法，是将它作为指向文件类型对象的指针。一旦你有这样的对象，就 可以调用其他“方法”来访问文件，如 read()和 write()。

读写文件使用read()和write()。

lseek()用于设置读取或写入文件中的特定偏移量。

用 fsync()立即写入。

系统调用 rename()用于重命名文件。

unlink()用于删除文件。

mkdir()、opendir()、readdir()和 closedir()、rmdir()用于进行目录操作。

* 硬连接：存放于目录中的`<inode id,filename>`关系。注意，不能创建目录的硬连接，并且硬连接也不能跨文件系统。
* 符号连接：特殊的文件类型，通过访问该文件来访问符号连接对应的原文件。符号链接与硬链接完全不同，删除名为 file 的原始文件会导致 符号链接指向不再存在的路径名。

> 创建一个文件时，实际上做了两件事。首先，要构建一个结构(inode)，它将跟踪几乎所有关于文件的信息，包括其大小、文件块 在磁盘上的位置等等。其次，将人类可读的名称链接到该文件，并将该链接放入目录中。

## 3. VSFS(Very Simple FS)的实现 ##

* superblock：包含关于该特定文件系统的信息， 包括例如文件系统中有多少个 inode 和数据块(在这个例子中分别为 80 和 56)、inode 表的 开始位置(块 3)等等。它可能还包括一些幻数，来标识文件系统类型(在本例中为 VSFS)。
* bitmap：位图(bitmap)，一种用于数据区域(数据位图，data bitmap)，另一种用于 inode 表(inode 位图，inode bitmap)
* inode table：保存了一个磁盘上 inode 的数组。可以使用多级索引或者范围索引来支持更大的文件。
* data region：存放用户数据。

![](https://raw.githubusercontent.com/yixy4app/images/picgo/202209131102498.png)

在 VSFS 中(像许多文件系统一样)，目录的组织很简单。一个目录基本上只包含一个二 元组(条目名称，inode 号)的列表。对于给定目录中的每个文件或目录，目录的数据块中都 有一个字符串和一个数字。简单的线性目录列表并不是存储这些信息的唯一方法。像 以前一样，任何数据结构都是可能的。例如，XFS 以 B 树形式存储目录，使文件创 建操作(必须确保文件名在创建之前未被使用)快于使用简单列表的系统，因为后者必须 扫描其中的条目。

读取和写入文件可能是昂贵的，会导致(慢速)磁盘的许多 I/O。 比如，必须遍历(traverse)路径名， 从而找到所需的 inode。这显然是一个巨大的性能问题，为了弥补，大多数文件系统积极使用系统内存(DRAM) 来缓存重要的块。

们也考虑一下缓存对写入的影响。尽管可以通过足够大的缓存完全避免读取 I/O， 但写入流量必须进入磁盘，才能实现持久。因此，高速缓存不能减少写入流量，像对读 取那样。虽然这么说，写缓冲(write buffering，人们有时这么说)肯定有许多优点。首 先，通过延迟写入，文件系统可以将一些更新编成一批(batch)，放入一组较小的 I/O 中。 例如，如果在创建一个文件时，inode 位图被更新，稍后在创建另一个文件时又被更新， 则文件系统会在第一次更新后延迟写入，从而节省一次 I/O。其次，通过将一些写入缓冲 在内存中，系统可以调度(schedule)后续的 I/O，从而提高性能。最后，一些写入可以 通过拖延来完全避免。例如，如果应用程序创建文件并将其删除，则将文件创建延迟写入 磁盘，可以完全避免(avoid)写入。在这种情况下，懒惰(在将块写入磁盘时)是一种 美德。

由于上述原因，大多数现代文件系统将写入在内存中缓冲 5~30s，这代表了另一种折 中:如果系统在更新传递到磁盘之前崩溃，更新就会丢失。但是，将内存写入时间延长， 则可以通过批处理、调度甚至避免写入，提高性能。
某些应用程序(如数据库)不喜欢这种折中。因此，为了避免由于写入缓冲导致的意 外数据丢失，它们就强制写入磁盘，通过调用 fsync()，使用绕过缓存的直接 I/O(direct I/O)接口，或者使用原始磁盘(raw disk)接口并完全避免使用文件系统1。虽然大多数应用程序 能接受文件系统的折中，但是如果默认设置不能令人满意，那么有足够的控制可以让系统 按照你的要求进行操作。

## 4. Fast File System，FFS的实现：进一步考虑适应磁盘

FSS的思路是让文件系统的结构和分配策略具有“磁盘意识”，从 而提高性能。FFS 进入了文件系统研究的新时代。通过保持与文 件系统相同的接口(相同的 API，包括 open()、read()、write()、close()和其他文件系统调用)， 但改变内部实现，作者为新文件系统的构建铺平了道路，这方面的工作今天仍在继续。事 实上，所有现代文件系统都遵循现有的接口(从而保持与应用程序的兼容性)，同时为了性 能、可靠性或其他原因，改变其内部实现。

FFS 将磁盘划分为一些分组，称为柱面组(cylinder group， 而一些现代文件系统，如 Linux ext2 和 ext3，就称它们为块组，即 block group)。这些分组是 FFS 用于改善性能的核心机制。通过在同一组中放置两个文件，FFS 可以 确保先后访问两个文件不会导致穿越磁盘的长时间寻道。因此，FFS 需要能够在每个组中分配文件和目录。

![](https://raw.githubusercontent.com/yixy4app/images/picgo/202209131330683.png)

出于可靠性原因，每个组中都有超级块(super block) 的一个副本(例如，如果一个被损坏或划伤，你仍然可以通过使用其中一个副本来挂载和 访问文件系统)。

## 5. FSCK和预写日志

系统可能在任何两次写入之间崩溃或断电，因此磁盘上状态可能仅部分地更新。崩溃后，系统启动 并希望再次挂载文件系统(以便访问文件等)。鉴于崩溃可能发生在任意时间点，如何确保文件系统将 磁盘上的映像保持在合理的状态?

较老的文件系统采用fsck，文件系统检查程序(file system checker)这种方法。请注意，这种方法无法解决所有问题。例如， 考虑上面的情况，文件系统看起来是一致的，但是 inode 指向垃圾数据。唯一真正的目标， 是确保文件系统元数据内部一致。

解决问题的另一种方法称为日志记录(journaling，也称为预写日志，write-ahead logging)，这种技术为每次写入增加一点开销，但可以更快地从崩溃或断电中恢复。

构建文件系统检查程 序的旧方法有效，但在现代系统上恢复可能太慢。因此，许多文件系统现在使用日志。日志可 将恢复时间从 O(磁盘大小的卷)减少到 O(日志大小)，从而在崩溃和重新启动后大大加快恢 复速度。因此，许多现代文件系统都使用日志。我们还看到日志可以有多种形式。最常用的是有 序元数据日志，它可以减少日志流量，同时仍然保证文件系统元数据和用户数据的合理一致性。

## 

<++>
**1.文件系统布局**

文件系统存放在磁盘上。多数磁盘划分为一个或多个分区，每个分区中有一个独立的文件系统。

![](https://raw.githubusercontent.com/yixy4app/images/picgo/202209102134122.jpg)

* 主引导记录(Master Boot Record, MBR)：位于磁盘的0号扇区，由BIOS读入并执行；作用是确定活动分区，读入并执行其引导块，引导块中的程序装载该分区的操作系统。
* 分区表：位于MBR结尾，其作用是给出每个分区的起始和结束地址。
* 引导块：每个分区都是从一个引导块开始，即使它不含有一个可启动的操作系统。

除了从引导块开始之外，磁盘分区的布局是随着文件系统的不同而变化。文件系统经常包含有如下项目：

* 超级块：包含文件系统的所有关键参数，在计算机启动或该文件系统首次使用时，把超级块读入内存。超级块的典型信息包括：确定文件系统类型用的魔数、文件系统中的数据块的数量以及其他重要的管理信息。
* 空闲空间管理：管理空闲块信息，例如可以用位图或者链表的形式记录。
* i节点：一个数据结构数据，每个文件一个，i节点说明了文件的方方面面。后面会重点谈到。
* 根目录：存放文件系统目录树的根部。
* 文件和目录：就是存放其他所有的目录和文件。

**2.文件存储实现**

前面说过，文件对于大多数操作系统来说就是一个字节序列，这是其逻辑上的结构。对于文件的存储实现，有以下几种。

* 连续分配：最简单的分配方案是把每个文件作为一连串连续数据块存储到磁盘上。
