# 并发-插叙:基于锁的并发数据结构

增加并发不一定能提高性能; 有性能问题的时候再做优化。避免不成熟的优化(premature optimization) , 对于所有关心性能的开发者都有用。我们让整个应用的某一小部分变快,却没有提高整体性能,其实没有价值。

## 1 同步计数器与懒惰计数器 ##

**同步计数器**简单、正确。实际上,它遵循了最简单、最基本的并发数据结构中常见的数据模式:它只是加了一把锁,在调用函数操作该数据结构时获取锁,从调用返回时释放锁。同步的计数器扩展性不好。如下图，单线程完成 100 万次更新只需要很短的时间(大约 0.03s) ,而两个线程并发执行, 每个更新 100 万次, 性能下降很多 (超过 5s! ) 。线程更多时,性能更差。

可以使用**懒惰计数器(sloppy counter)**来实现更好的扩展性。通过多个局部计数器和一个全局计数器来实现一个逻辑计数器,其中每个CPU 核心有一个局部计数器。具体来说,在 4 个 CPU 的机器上,有 4 个局部计数器和 1 个全局计数器。除了这些计数器,还有锁:每个局部计数器有一个锁,全局计数器有一个。 懒惰计数器的基本思想是这样的。如果一个核心上的线程想增加计数器,那就增加它的局部计数器,访问这个局部计数器是通过对应的局部锁同步的。因为每个 CPU 有自己的局部计数器,不同 CPU 上的线程不会竞争,所以计数器的更新操作可扩展性好。但是,为了保持全局计数器更新(以防某个线程要读取该值) ,局部值会定期转移给全局计数器,方法是获取全局锁,让全局计数器加上局部计数器的值,然后将局部计数器置零。 这种局部转全局的频度,取决于一个阈值,这里称为 S(表示 sloppiness) 。S 越小,懒惰计数器则越趋近于非扩展的计数器。S 越大,扩展性越强,但是全局计数器与实际计数的偏差越大。我们可以抢占所有的局部锁和全局锁(以特定的顺序,避免死锁) ,以获得精确值,但这种方法没有扩展性。如果 S 小,性能很差(但是全局计数器精确度高) 。如果 S 大,性能很好,但是全局计数器会有延时。懒惰计数器就是在准确性和性能之间折中。

![](https://raw.githubusercontent.com/yixy4app/images/picgo/202209102133938.png)

## 2 并发链表 ##

注意，不应该在代码插入函数入口处获取锁, 函数结束时释放锁。（除了性能外，如果 malloc 失败 (在极少的时候) ,会有一点小问题,在这种情况下,代码在插入失败之前,必须释放锁。事实表明,这种异常控制流容易产生错误。）实际上，我们应该调整代码,让获取锁和释放锁只环绕插入代码的真正临界区。


```
int List_Insert(list_t *L, int key) { 
	//pthread_mutex_lock(&L->lock);  --synchronization not needed
	node_t *new = malloc(sizeof(node_t));
	if (new == NULL) {
		perror("malloc");
		pthread_mutex_unlock(&L->lock);
		return -1; // fail
	}

	// just lock critical section
	pthread_mutex_lock(&L->lock);  
	new->key = key;
	new->next = L->head;
	L->head = new;
	//pthread_mutex_unlock(&L->lock); 

	return 0; // success 31   
}
```

尽管我们有了基本的并发链表,但又遇到了这个链表扩展性不好的问题。研究人员发现的增加链表并发的技术中,有一种叫作过手锁(hand-over-hand locking,也叫作锁耦合, lock coupling)。原理也很简单。每个节点都有一个锁,替代之前整个链表一个锁。遍历链表的时候, 首先抢占下一个节点的锁,然后释放当前节点的锁。

从概念上说,过手锁链表有点道理,它增加了链表操作的并发程度。但是实际上,在遍历的时候,每个节点获取锁、释放锁的开销巨大,很难比单锁的方法快。即使有大量的线程和很大的链表, 这种并发的方案也不一定会比单锁的方案快。 也许某种杂合的方案 (一定数量的节点用一个锁)值得去研究。

## 3 并发队列 ##

针对并发队列（队尾入，队首出），可以设置有两个锁,一个负责队列头,另一个负责队列尾。这两个锁使得入队列操作和出队列操作可以并发执行, 因为入队列只访问 tail 锁, 而出队列只访问 head 锁。

## 4 并发散列表 ##

散列表使用我们之前实现的并发链表,性能特别好。每个散列桶(每个桶都是一个链表)都有一个锁,而不是整个散列表只有一个锁,从而支持许多并发操作。
