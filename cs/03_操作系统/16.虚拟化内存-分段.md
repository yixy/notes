# 虚拟化内存-机制:分段

重定位技术的一个典型地问题是：内部碎片。由于该进程的栈区和堆区并不很大，栈和堆之间，有一大块“空闲”空间，空间存在大量浪费（因为需要预留增长空间）。这种浪费通常称为**内部碎片 (internal fragmentation) **， 指的是已经分配的内存单元内部有未使用的空间(即碎片) ，造成了浪费。另外，如果剩余物理内存无法提供连续区域来放置完整的地址空间，进程便无法运行，看起来基址加界限的方式看来并不像我们期望的那样灵活。在我们当前的方式中，即使有足够的物理内存容纳更多进程，但我们目前要求将地址空间放在固定大小的槽块中，因此会出现内部碎片。所以，我们需要更复杂的机制，以便更好地利用物理内存，避免内部碎片。第一次尝试是将基址加界限的概念稍稍泛化，得到分段(segmentation)的概念。

分段后，只有已用的内存才在物理内存中分配空间。此时，每个段的界限寄存器可以限制大小，因为程序实际上用不完虚拟地址空间。

## 1 分段 ##

一个直观并且通用的方法是在机器上提供多个互相独立的称为**段（segment）**的地址空间。每个段由一个从0到最大的线性地址序列构成。各个段的长度可以是0到某个允许的最大值之间的任何一个值。不同的段的长度可以不同，并且通常情况下也都不相同。段的长度在运行期间可以动态改变。在 MMU 中引入不止一个基址和界限寄存器对，而是给地址空间内的每个逻辑段(segment)一对。一个段只是地址空间里的一个连续定长的区域，在典型的地址空间里有 3 个逻辑不同的段:代码、栈和堆。分段的机制使得操作系统能够将不同的段放到不同的物理内存区域，从而避免了虚拟地址空间中的未使用部分占用物理内存。

> 段错误指的是在支持分段的机器上发生了非法的内存访问。有趣的是，即使在不支持分段的机器上这个术语依然保留。

需要强调的是，段是一个逻辑实体，程序员知道这一点并把它作为一个逻辑实体来使用。一个段可能包括一个过程、一个数组、一个堆栈、一组数值变量，但一般它不会同时包含多种不同类型的内容。

## 2 硬件如何判断地址引用了哪个段 ##

硬件在地址转换时使用段寄存器。 它如何知道段内的偏移量， 以及地址引用了哪个段? 

一种常见的方式，有时称为**显式(explicit)方式**，就是用虚拟地址的开头几位来标识不同的段。

在另一种**隐式(implicit)方式**中，硬件通过地址产生的方式来确定段。例如，如果地址由程序计数器产生(即它是指令获取) ，那么地址在代码段。如果基于栈或基址指针，它一定在栈段。其他地址则在堆段。

## 3 其他：栈段和共享段的支持 ##

对于栈段，我们还需要一点硬件支持。除了基址和界限外，硬件还需要知道**栈段的增长方向**(用一位区分，比如 1 代表自小而大增长，0 反之) 。

要节省内存，有时候在地址空间之间**共享(share)某些内存段**是有用的。尤其是，代码共享很常见，今天的系统仍然在使用。为了支持共享，需要一些额外的硬件支持，这就是保护位(protection bit) 。基本为每个段增加了几个位，标识程序是否能够读写该段，或执行其中的代码。通过将代码段标记为只读，同样的代码可以被多个进程共享，而不用担心破坏隔离。虽然每个进程都认为自己独占这块内存，但操作系统尽密地共享了内存，进程不能修改这些内存，所以假象得以保持。

有了保护位，硬件检测算法也必须改变。除了检查虚拟地址是否越界，硬件还需要检查特定访问是否允许。如果用户进程试图写入只读段，或从非执行段执行指令，硬件会触发异常，让操作系统来处理出错进程。

## 4 段的粒度 ##

到目前为止，我们的例子大多针对只有很少的几个段的系统(即代码、栈、堆) 。我们可以认为这种分段是粗粒度的(coarse-grained) ，因为它将地址空间分成较大的、粗粒度的块。但是，一些早期系统(如 Multics[CV65， DD68])更灵活，允许将地址空间划分为大量较小的段，这被称为细粒度(fine-grained)分段。

## 5 小结：硬件及操作系统提供的支持 ##

硬件支持：在基址和界限寄存器原有支持的基础上，硬件还需要支持**判断虚拟地址引用了哪个段，并且通过增加位支持栈增长方向的区分，增加保护位增加访问检测判断**。

操作系统支持：同样的，操作系统需要提供管理内存(manage memory) 的功能，记录被占用和空闲的内存位置，并明智而谨慎地介入（比如这**上下文切换时做对应的处理，保存多对基址和界限寄存器的值**），保持对内存使用的控制。
