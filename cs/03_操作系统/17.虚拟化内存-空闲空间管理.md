# 虚拟化内存-机制:空闲空间管理

不管是使用重定位技术，还是在此基础上泛化产生的分段机制。在进程创建时,操作系统必须为进程的地址空间找到内存空间，在进程终止时(正常退出,或因行为不端被强制终止) ,操作系统也必须做一些工作,回收它的所有内存,给其他进程或者操作系统使用。可见，**如何管理物理内存的空闲空间是我们需要重点关注的一个问题**。

让问题更明确一点。如果需要管理的空间被划分为固定大小的单元,就很容易。在这种情况下,只需要维护这些大小固定的单元的列表,如果有请求,就返回列表中的第一项。 如果要管理的空闲空间由大小不同的单元构成,管理就变得困难(而且有趣) 。这种情况出现在用户级的内存分配库(如 malloc()和 free()) ,或者操作系统用分段(segmentation) 的方式实现虚拟内存。在这两种情况下,出现了**外部碎片(external fragmentation)的问题**: 空闲空间被分割成不同大小的小块,成为碎片,物理内存很快充满了许多空闲空间的小洞,因而很难分配给新的段, 或扩大已有的段。后续的请求可能失败,因为没有一块足够大的连续空闲空间,即使这时总的空闲空间超出了请求的大小。该问题的一种解决方案是紧凑(compact)物理内存,重新安排原有的段。但是,内存紧凑成本很高,因为拷贝段是内存密集型的,一般会占用大量的处理器时间。一种更简单的做法是利用空闲列表管理算法,试图保留大的内存块用于分配。相关的算法可能有成百上千种,包括传统的最优匹配(best-fit,从空闲链表中找最接近需要分配空间的空闲块返回) 、 最坏匹配 (worst-fit) 、 首次匹配 (first-fit) 以及像伙伴算法 (buddy algorithm) 这样更复杂的算法。但遗憾的是,无论算法多么精妙,都无法完全消除外部碎片,因此,好的算法只是试图减小它。

下面将讨论不定长的内存空闲空间(free-space management)管理系统的一个基本方面，无论是 malloc 库(管理进程中堆的页) ,还是操作系统本身(管理进程的地址空间) ，我们将看看如何尽量减少外部碎片带来的影响。

## 1. 使用位图的存储管理 ##

* 位图：顾名思义，可以看成是一个bit表。内存可能被划分为几个字或几千字节的分配单元，每个分配单元对应位图中的一位，0表示空闲，1表示占用。

使用位图时的主要问题是，在决定分配k个单元时，系统必须对位图进行搜索，在其中找出有k个值连续为0的串，这是一个耗时的操作（因为位图中该串可能跨越字的边界）。

## 2. 使用链表的存储管理 ##

空闲列表包含一组元素,记录了堆中的哪些空间还没有分配。

分配程序会执行所谓的**分割(splitting) 动作**:它找到一块可以满足请求的空闲空间,将其分割,第一块返回给用户,第二块留在空闲列表中。分配程序还会执行**合并(coalescing)机制**：在归还一块空闲内存时,仔细查看要归还的内存块的地址以及邻近的空闲空间块。如果新归还的空间与一个原有空闲块相邻(或两个,就像这个例子) ,就将它们合并为一个较大的空闲块。

使用链表的存储管理需要维护一个记录已分配内存和空闲内存的链表。

* 已分配内存链表：链表中一个节点包含一个进程所占据的内存区。
* 空闲内存链表：链表中一个节点包含两个进程之间的一个空闲区。

通过在每个元素设置头部，追踪已分配的大小：（这就是类似free方法实现时，不需要用户传递参数大小的原因）

![](https://raw.githubusercontent.com/yixy4app/images/picgo/202209102128807.png)

使用链表数据结构时，常见的内存分配算法如下，仿真程序试验表明，后三种算法并不比首次适配算法更优秀。

* 首次适配算法：从头开始搜索链表，直到找到足够大的空闲区，除非空闲区与待分配空间大小一样，否则将该空闲区分为两部分，一部分供进程使用，另一部分形成新的空闲区。
* 下次适配算法：与首次适配算法方式基本相同。区别在于，每次找到合适的空闲区时都记录当时的位置，以便在下次寻找空闲区时从该位置开始搜索。（bays 1977 的仿真程序证明下次适配算法性能略低于首次适配算法）
* 最优适配算法：每次搜索整个链表，找出能够分配的最小的空闲区进行分配。
* 最差适配算法：每次搜索整个链表，找出能够分配的最大的空闲区进行分配。

## 3 小结：操作系统的支持 ##

关于进程地址空间的管理（非固定单元的空闲空间管理机制），均由操作系统提供。

> malloc库的空闲空间管理策略由库开发者实现。
