# 虚拟化内存-插叙:内存操作API

在运行一个 C 程序的时候，会分配两种类型的内存。第一种称为栈内存，它的申请和释放操作是编译器来隐式管理的，所以有时也称为自动(automatic)内存。第二种称为堆(heap) 内存，用于将某些信息存在于函数调用之外，其中所有的申请和释放操作都由程序员显式地完成。

malloc()和 free()都不是系统调用。malloc 库管理虚拟地址空间内的空间，但是它本身是建立在一些系统调用之上的，这些系统调用会进入操作系统，来请求更多内存或者将一些内容释放回系统。 一个这样的系统调用叫作 brk， 它被用来改变程序分断 (break) 的位置: 堆结束的位置。它需要一个参数(新分断的地址) ，从而根据新分断是大于还是小于当前分断，来增加或减小堆的大小。另一个调用 sbrk 要求传入一个增量，但目的是类似的。 请注意， 你不应该直接调用 brk 或 sbrk。 它们被内存分配库使用。 如果你尝试使用它们， 很可能会犯一些错误。建议但持使用 malloc()和 free()。 最后，你还可以通过 mmap()调用从操作系统获取内存。通过传入正确的参数，mmap() 可以在程序中创建一个匿名 (anonymous) 内存区域——这个区域不与任何特定文件相关联， 而是与交换空间(swap space)相关联。

## 1 malloc()调用 ##

malloc 函数非常简单:传入要申请的堆空间的大小，它成功就返回一个指向新申请空间的指针，失败就返回 NULL。只需要包含头文件 stdlib.h 就可以使用 malloc 了。但实际上， 甚至都不需这样做，因为 C 库是 C 程序默认链接的，其中就有 mallock()的代码，加上这个头文件只是让编译器检查你是否正确调用了 malloc() (即传入参数的数目正确且类型正确) 。

## 2 free()调用

要释放不再使用的堆内存，程序员只需调用 free()。free()期望你只传入之前从 malloc() 得到的一个指针。该函数接受一个参数，即一个由 malloc()返回的指针。 因此，你可能会注意到，分配区域的大小不会被用户传入，必须由内存分配库本身记录追踪。

## 3 一些常见都问题 ##

* 忘记分配内存
* 没有分配足够的内存
* 忘记初始化分配的内存
* 忘记释放内存
* 在用完之前释放内存
* 反复释放内存
* 错误地调用 free()：free()期望你只传入之前从 malloc() 得到的一个指针。后面可以看到，这与空闲内存管理的策略相关。
