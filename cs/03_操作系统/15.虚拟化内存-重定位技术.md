# 虚拟化内存-机制:重定位技术

可以采用**重定位技术**支持多道程序在系统中运行，实现更有效率的时分共享程序（在进程切换的时候， 仍然将进程信息放在内存中）。

## 1 静态重定位（基于软件的重定位） ##

**静态重定位（static relocation，也称为基于软件的重定位）**：指在程序执行之前，在装载过程中完成程序地址重定位。在程序装载到内存时，系统为每个程序地址加上一个偏移量常数。实际上是一个名为加载程序(loader)的软件接手将要运行的可执行程序，将它的地址重写到物理内存中期望的偏移位置。

然而，静态重定位有许多问题，首先也是最重要的是不提供访问保护，进程中的错误地址可能导致对其他进程或操作系统内存的非法访问，一般来说，需要硬件支持来实现真正的访问保护。静态重定位的另一个缺点是一旦完成，稍后很难将内存空间重定位到其他位置。

## 2 动态重定位（基于硬件的重定位）: 即硬件地址转换技术 ##

**动态重定位（dynamic relocation，也称为基于硬件的重定位）**：使用基址加界限机制(base and bound) ，由硬件实现在程序运行中进行地址重定位。当一个进程运行时，程序在内存中的起始物理位置读取到基址寄存器中，程序的长度读取到界限寄存器中。进程每次访问内存时，CPU硬件会在把地址发送到内存总线前，自动把基址值加到进程发出的地址上，同时检查程序提供的地址是否合法（是否超过界限值）。

具体来说，每个 CPU 需要两个硬件寄存器:**基址(base)寄存器和界限(bound)寄存器**，有时称为限制(limit)寄存器。这组基址和界限寄存器，让我们能够将地址空间放在物理内存的任何位置，同时又能确保进程只能访问自己的地址空间。采用这种方式，在编写和编译程序时假设地址空间从零开始。但是，当程序真正执行时， 操作系统会决定其在物理内存中的实际加载地址，并将起始地址记录在基址寄存器中。

该进程产生的所有内存引用，都会被处理器通过以下方式转换为物理地址: ** physical address = virtual address + base**

将虚拟地址转换为物理地址，这正是所谓的**地址转换(address translation)技术**。也就是说，硬件取得进程认为它要访问的地址，将它转换成数据实际位于的物理地址。基于硬件的地址转换(hardware-based address translation) ，简称为地址转换(address translation) 。利用地址转换，硬件对每次内存访问进行处理(即指令获取、数据读取或写入) ，将指令中的虚拟(virtual)地址转换为数据实际存储的物理(physical)地址。因此， 在每次内存引用时，硬件都会进行地址转换，将应用程序的内存引用重定位到内存中实际的位置。

如果进程需要访问超过这个界限或者为负数的虚拟地址，CPU 将触发异常，进程最终可能被终止。界限寄存器的用处在于，它确保了进程产生的所有地址都在进程的地址“界限”中。 这种基址寄存器配合界限寄存器的硬件结构是芯片中的 (每个 CPU 一对) 。 有时我们将CPU 的这个负责地址转换的部分统称为内存管理单元(Memory Management Unit，MMU) 。随着我们开发更复杂的内存管理技术，MMU 也将有更复杂的电路和功能。 关于界限寄存器再补充一点， 它通常有两种使用方式。 在一种方式中 (像上面那样) ， 它记录地址空间的大小，硬件在将虚拟地址与基址寄存器内容求和前，就检查这个界限。另一种方式是界限寄存器中记录地址空间结束的物理地址，硬件在转化虚拟地址到物理地址之后才去检查这个界限。这两种方式在逻辑上是等价的。简单起见，我们这里假设采用第一种方式。

> 硬件应该提供一些特殊的指令,用于修改基址寄存器和界限寄存器,允许操作系统在切换进程时改变它们。这些指令是特权(privileged)指令,只有在内核模式下,才能修改这些寄存器。在用户程序尝试非法访问内存 (越界访问) 时, CPU必须能够产生异常 (exception) 。在这种情况下,CPU 应该阻止用户程序的执行,并安排操作系统的“越界”异常处理程序(exception handler)去处理。操作系统的处理程序会做出正确的响应,比如在这种情况下终止进程。类似地,如果用户程序尝试修改基址或者界限寄存器时,CPU 也应该产生异常, 并调用“用户模式尝试执行特权指令”的异常处理程序。

> 在上下文切换时,操作系统也必须执行一些额外的操作。每个 CPU 毕竟只有一个基址寄存器和一个界限寄存器,但对于每个运行的程序,它们的值都不同,因为每个程序被加载到内存中不同的物理地址。因此,在切换进程时,操作系统必须保存和恢复基础和界限寄存器。具体来说,当操作系统决定中止当前的运行进程时,它必须将当前基址和界限寄存器中的内容保存在内存中, 放在某种每个进程都有的结构中, 如进程结构 (process structure)或进程控制块(Process Control Block,PCB)中。类似地,当操作系统恢复执行某个进程时(或第一次执行) ,也必须给基址和界限寄存器设置正确的值。此外操作系统必须提供异常处理程序(exception handler) ,或要一些调用的函数,像上面提到的那样。操作系统在启动时加载这些处理程序(通过特权命令) 。

## 3 小结：硬件及操作系统提供的支持 ##

在动态重定位的过程中，只有很少的硬件参与，但获得了很好的效果。**硬件支持：一个基址寄存器将虚拟地址转换为物理地址，一个界限寄存器确保这个地址在进程地址空间的范围内。它们一起提供了既简单又高效的虚拟内存机制。**

当然，仅仅依靠硬件不足以实现虚拟内存，因为它只是提供了底层机制来提高效率。操作系统必须在关键的位置介入，设置好硬件，以便完成正确的地址转换。因此**操作系统必须管理内存(manage memory) ，记录被占用和空闲的内存位置，并明智而谨慎地介入（比如这上下文切换时做对应的处理），保持对内存使用的控制。**

同样，所有这些工作都是为了创造一种美丽的假象:每个程序都拥有私有的内存，那里存放着它自己的代码和数据。虚拟现实的背后是丑陋的物理事实:许多程序其实是在同一时间共享着内存，就像 CPU(或多个 CPU)在不同的程序间切换运行。通过虚拟化， 操作系统(在硬件的帮助下)将丑陋的机器现实转化成一种有用的、强大的、易于使用的抽象。
