# 虚拟化CPU-进程API

所有现代操作系统都以某种形式提供这些 API。

* 创建(create):操作系统必须包含一些创建新进程的方法。在 shell 中键入命令或双击应用程序图标时，会调用操作系统来创建新进程，运行指定的程序。 
* 销毁(destroy):由于存在创建进程的接口，因此系统还提供了一个强制销毁进程的接口。当然，很多进程会在运行完成后自行退出。但是，如果它们不退出， 用户可能希望终止它们，因此停止失控进程的接口非常有用。 
* 等待(wait):有时等待进程停止运行是有用的，因此经常提供某种等待接口。 
* 其他控制(miscellaneous control):除了杀死或等待进程外，有时还可能有其他控制。例如，大多数操作系统提供某种方法来暂停进程(停止运行一段时间)， 然后恢复(继续运行)。
* 状态(statu):通常也有一些接口可以获得有关进程的状态信息，例如运行了多长时间，或者处于什么状态。

## 2 fork和exec ##

```
#调用fork函数生成子进程，fork生成的子进程相当于于父进程的一个拷贝
if((pid=fork())<0)
	#error
else if (pid>0)
	#父进程执行代码
else if (pid==0)
	#子进程执行代码
	...
	#调用exec对当前进程进行替换，替换成为一个指定的程序。
	exec #调用exec转变为新进程，但保留进程号。注意，默认情况下，新进程不会关闭原进程的打开文件描述符或进行内存清理。
```

任何一个现有进程可以调用fork函数创建一个新进程，由fork创建的新进程被称为子进程（child process）。fork函数被调用一次，但返回两次。两次返回的唯一区别是子进程中fork的返回值是0，而父进程中fork的返回值则是新子进程的进程ID。此时，子进程是父进程的副本。子进程和父进程继续执行fork调用之后的指令。

用fork函数创建子进程后，子进程可以调用exec函数以执行另一个程序。当进程调用exec函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。因为调用exec并不创建新进程，所以前后的进程ID并未改变。exec只是用一个全新的程序替换了当前进程的代码、数据、堆和栈段。

## 3 wait ##

父进程调用wait()，延迟自己的执行，直到子进程执行完毕。当子进程结束时，wait()才返回父进程。

## 4 为什么这样设计 API ##

事实证明，这种分离 fork()及 exec()的做法在构建 UNIX shell 的时候非常有用， 因为这给了 shell 在 fork 之后 exec 之前运行代码的机会， 这些代码可以在运行新程序前改变环境，从而让一系列有趣的功能很容易实现。

shell 也是一个用户程序1，它首先显示一个提示符(prompt) ，然后等待用户输入。你可以向它输入一个命令(一个可执行程序的名称及需要的参数) ，大多数情况下，shell 可以在文件系统中找到这个可执行程序，调用 fork()创建新进程，并调用 exec()的某个变体来执行这个可执行程序，调用 wait()等待该命令完成。子进程执行结束后，shell 从 wait()返回并再一输出一个提示符，等待用户输入下一条命令。 

fork()和 exec()的分离，让 shell 可以方便地实现很多有用的功能。比如:

```
prompt> wc p3.c > newfile.txt
```

在上面的例子中， wc 的输出结果被重定向 (redirect) 到文件 newfile.txt 中 (通过 newfile.txt 之前的大于号来指明重定向) 。shell 实现结果重定向的方式也很简单，当完成子进程的创建后，shell 在调用 exec()之前先关闭了标准输出(standard output) ，打开了文件 newfile.txt。
这样，即将运行的程序 wc 的输出结果就被发送到该文件，而不是打印在屏幕上。

重定向的工作原理，是基于对操作系统管理文件描述符方式的假设。 具体来说， UNIX 系统从 0 开始寻找可以使用的文件描述符。

UNIX 管道也是用类似的方式实现的，但用的是 pipe()系统调用。在这种情况下，一个进程的输出被链接到了一个内核管道(pipe)上(队列) ，操一个进程的输入也被连接到了同一个管道上。因此，前一个进程的输出无缝地作为后一个进程的输入，许多命令可以用这种方式串联在一起，共同完成某项任务。比如通过将 grep、wc 命令用管道连接可以完成从一个文件中查找某个词，并统计其出现一数的功能:grep -o foo file | wc -l。
