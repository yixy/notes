# 定时器算法-链表&小堆&时间轮

程序里的定时器是储存定时任务的集合，定时任务是在未来的某个时间点执行的任务。在定时器模型中，一般会设置任务开始时间，一个轮询线程负责每隔一个时间单位会检查是否有任务需要处理。

定时器涉及如下主要操作。

* 新增任务（初始化一个定时任务）
* 任务检测策略（轮询线程需要每隔一个时间单位进行检查，该策略用于定位到需要启动或者删除的任务）
* 启动和删除任务（轮询线程负责启动任务，总是O(1)复杂度，然后移除过期任务，复杂度取决于数据结构）

下面讨论定时器在内存中的数据结构和算法实现。

## 1 链表实现 ##

链表的实现方法比较粗糙。链表用于存储所有的定时器，每个定时器都含任务开始的相对时间interval，另外还有elapse参数，elapse表示当前被tickTimer了多少次。当elapse 和interval相等时，表示任务开始执行。

在此方案中，添加定时器就是在链表的末尾新增一个节点，时间复杂度是 O(1)。此方案下，每隔tickTimer时间，系统进行超时检查，即PerTickBookkeeping。每次PerTickBookkeeping需要对链表所有定时器进行 elapse++，因此可以看出PerTickBookkeeping的时间复杂度是O(N)。虑删除一个定时器的操作话，针对链表，我们需要遍历链表找到对应的定时器，时间复杂度是O(n)。

## 2 改进后的排序双向链表实现 ##

排序双向链表是在链表实现上的优化。优化思路是降低时间复杂度。

为了不需要对每个定时器进行操作，我们将定时器进行排序，那么每次PerTickBookkeeping都只需要判断第一个定时器就能定位到需要处理的定时器（如果有），同时，我们将interval变为绝对时间，那么我们只需要比较当前时间和该时间是否相等，避免每次PerTickBookkeeping需要自增所有定时器的elapse变量，此时PerTickBookkeeping时间复杂度为O(1)。相应的，为了维持链表顺序，每次新增定时器需要进行链表排序时间复杂度为 O(N)。每次删除定时器时，由于会持有自己节点的引用（因为有反向指针），所以不需要查找其在链表中所在的位置，所以时间复杂度为O(1)，这是双向链表的好处。

## 3 小根堆实现 ##

小堆的插入时间复杂度是O(lgN)。最小堆的删除和插入逻辑基本类似，如果不做优化，时间复杂度也是O(lgN)。但是实际实现方案上，做了延迟删除操作，时间复杂度为O(1)。延迟删除即设置定时器的执行回调函数为空，每次最小堆超时，将触发pop_heap，pop会重新调整最小堆，最终删除的定时器将调整到堆顶，但是回调函数不处理。可以看到PerTickBookkeeping只处理堆顶定时器，时间复杂度O(1)。

## 4 时间轮算法 ##

时间轮的数据结构是环状数组 + 链表。参照时钟运转的思路，每个相同刻度下的任务启动时间是相同的，将所有相同时间的时间放在一个槽（数组的一个元素）中，通过用一个指针每过一个刻度指向时间轮的槽，取出槽中链表，循环遍历相同刻度下的事件。（liunx内核就是这么做的）。

可以设置多级时间轮，保障能容纳更多定时任务，不同层级时间轮的时间槽单位不同。每次任务初始化时，任务会先放到高层时间轮对应位置，然后等指针拨到对应位置时，再下移到下层时间轮，如此反复直到定时任务移到最底层时间轮，并且指针拨动到相关位置时才会执行。比如时、分、秒三级时间轮，会先将任务放到小时层时间轮对应位置；当小时时间轮指针拨动到该位置时，将该位置的定时任务下移到分钟时间轮中相应位置；当分钟时间轮指针拨动到该位置时，将该位置的定时任务下移到秒时间轮中相应位置；当秒时间轮指针拨动到相应位置时，执行链表中的定时任务。（这里忽略了边界情况的讨论，不再赘述）

时间轮数组新增和删除一个任务，时间复杂度都是O(1)。PerTickBookkeeping每次转动一格，时间复杂度也是O(1)。

## 5 算法比较 ##

从上面的介绍来看，时间轮的时间复杂度最小、性能最好。

下面讨论使用场景。

在任务量小的场景下：最小堆实现，可以根据堆顶设置超时时间，数组存储结构，节省内存消耗，使用最小堆可以得到比较好的效果。而时间轮定时器，由于需要维护一个线程用来拨动指针，且需要开辟一个bucket数组，消耗内存大，使用时间轮会较为浪费资源。

在任务量大的场景下：最小堆的插入复杂度是O(lgN), 相比时间轮O(1) 会造成性能下降。更适合使用时间轮实现。在业界，服务治理的心跳检测等功能需要维护大量的链接心跳，因此时间轮是首选。
