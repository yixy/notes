# cache-三级缓存设计 #

## 1 三级缓存设计思路 ##

考虑空间大小，速度，容量，缺失率，缺失代价，成本等等因素之间的平衡，处理器中的Cache 被设计为三级。

**现代处理器一般有三层cache，分别称为L1 cache、L2 cache、L3 cache。L1 cache离CPU核最近，存储信息的读取速度接近CPU核的工作速度，容量较小，一般分成I-cache和D-cache两块，分别存储指令和数据；L2 cache比L1更远，速度慢一些，但是容量更大，不分I-cache和D-cache；L3更慢、更大，现在流行多核处理器，L3一般由多个处理器核共享，而L1、L2是单核私有的。**

3级缓存(L1，L2，L3)的访问延时逐渐增加，所以，最佳场景是即将执行的指令和数据在L1就命中，其次L2，再其次L3。如果L1，L2，L3都没有命中，则CPU就只能去内存中取数据了。而**由于分支预测，路预测（Way prediction）等技术，Intel与AMD的CPU的缓存命中率通常可以达到95%以上**，这可以保证CPU运行过程中不会空转，保证了程序的运行效率。

对于L1缓存来说，作为最靠近CPU核的部件，它的频率是与CPU核同频的，以Ghz为单位，同时它的容量是比较小的，一般情况下只有几十kB到几百kB不等。而对于L2,L3，缓存的容量不断加大，一般L2的容量是几百KB到几MB不等，而L3一般是十几MB。访问延时也在不断增高。Core访问需要等待的时钟周期也不断增加。

## 2 设计考虑（为什么是3级） ##

对于CPU多核心的场景下，每个核心的L1,L2缓存都只能被这个核访问，别的核无法访问，L1，L2是这个核的私有缓存。而相对应的，L3缓存被以某种协议或者方式链接到CPU内的一种总线上，供所有核访问，所以，**L3为共享缓存**。

指令缓存与数据缓存。指令缓存是专门用来给CPU提供指令的，而数据缓存是专门给CPU提供数据的。请注意，是提供指令和数据。指令缓存中偶尔也会存入数据，数据缓存中也偶尔存入指令。但是存归存，CPU核不会在指令缓存中读取数据，也不会在数据缓存里读取指令，除非有BUG。而**指令缓存与数据缓存的区别只会在L1存在。L2缓存是同时存储指令和数据的**。为什要区分指令缓存和数据缓存？因为L1缓存的容量是比较小的。我们知道Cache是不断刷新的，假设对于L1缓存，刚存上来一堆指令，啪，被下一波数据给替换掉了，这样就会导致指令读取不命中，又得去L2取，这样得不偿失。所以需要搞出L1和L2。

> 一级 Cache 都是分为两部分，数据 Cache 和 指令 Cache，这种结构叫做哈佛结构，与之区别对应的为冯诺依曼结构，冯诺依曼结构虽然到处都在提及，但现今的实际工程当中不会那么设计，效率很低。就拿指令和数据分开来说，为什么要分开，因为现在的 CPU 都支持流水线，取值和访存是可以分开进行的，取值和访存分开进行除了流水线这一前提之外还有个前提，那就是指令和数据得在两个存储器当中，不然就会引起冲突，这有个专有名词叫做结构相关。

对于CPU而言，L1,L2是专门给一个核设计的，L3是给一个CPU内的多核设计的。L1,L2,L3各司其职，以及满足了一个CPU的需求了，如果Cache容量缺的话，我们加大一下各级的大小不就好了嘛，那么为什么还要设计出L4呢？没必要。况且，对于一个CPU而言，缓存实在是太占有CPU的单元面积了，如下图，L3缓存就已经占有了四个核的面积了，再搞出L4，那又得塞出多大的一块呢？当然，有人提到锐炬系列中已经出了L4了，但是我感觉，那是当显存用。偶尔作为缓存，从功能上划分，只是扩充了L3的容量，而不是L4。

## 3 Inclusive与Exclusive模式 ##

既然缓存分为三级，那么要考虑一下三级缓存直接是怎么协作的。对于缓存的协作方法上，Intel与AMD很有默契的分成了两种阵营。Inclusive模式与Exclusive模式。

首先来说一下**Intel采用的Inclusive(包含)模式**，这种模式下，L3的缓存包含了缓存的所有内容。也就是说L2缓存的内容是L3的子集，L1的内容又是L2的子集。内存中被缓存的内容会首先进入到L3中。这种模式的好处就是，当一个CPU核发现L3缓存没有命中后，完全可以确定别的CPU核的缓存也没有命中。而且上层的Cache与底层Cache的数据交换更快。因为假设L1发现L2有需要的数据，直接从底层Cache复制一份上来就可以了，无需做别的操作。但是缺点就是会空间浪费，也会产生缓存一致性问题，例如一个CPU核修改了某个缓存行的内容，那么别这个Cacheline在别的Cache中的数据就是过时的，需要进行额外的操作。

而**AMD选择的Exclusive(排斥)模式**下，L1,L2,L3是一个大的整体。也就是所有的缓存中，每一份数据都是唯一的，这个好处就是，首先不会造成空间浪费，所有缓存没有副本，而且也不会存在上文所说的一个核更改缓存行，别的数据副本过时的问题，因为数据只有一份。但是缺点也比较明显，更改一份数据需要更多的操作，同样假设L1发现L2有需要的缓存数据，不仅仅需要复制，还需要把L2的该数据的缓存行设为无效。而且内存中被缓存的内容会首先进入到L1缓存中，当L1的缓存占满后，会把优先级可能没那么高的数据放入L2，如果L2也被占满，就移到L3，如果L3也满了，直接淘汰掉。这样看，AMD的三层缓存更像三个仓库，L1是最近的小仓库，拿起来更方便，L1满了就往L2那个仓库里扔，L2满了，就往L3扔。


