# 性能分析——如何编写高性能代码 #

## 1. 性能指标 ##

* Wall Time：墙上时钟时间，程序运行的绝对时间（包括程序阻塞时间）
* CPU Time：
* 内存分配

## 2. 别让性能被锁住 ##

即使是使用读锁，仍然是有性能开销的。有锁和无锁可能有一个数量级差别（10+ms和100+ms）。

* 减少锁影响的范围：能不用锁的地方就不用
* 减少锁冲突的概率：读多写少用sync.Map；写多读少/写多读多用concurrent_map（`https://github.com/easierway/concurrent_map`）
* 不使用锁：例如使用LAMX Disruptor

https://tech.meituan.com/2016/11/18/disruptor.html

## 3. GC友好的代码 ##

核心思路是尽量避免内存的分配和复制。

* 复杂对象尽量传递指针：大数组传递、大结构体传递
* 初始化至合适的大小：太小的话，自动扩容是有代价的（slice）；太大的话，利用率低，增加额外性能开销（如对象拷贝、GC）。
* 高性能字符串连接：避免反复申请内存，StringBuilder
* 复用内存

## ##

仔细分析之后可以得到一个大概结论，reflect慢主要有两个原因：一是涉及到内存分配以后GC；二是reflect实现里面有大量的枚举，也就是for循环，比如类型之类的。

因为反射中使用了类型的枚举，所以效率比较低，在高性能场景中应该尽量规避，但是，对于大部分应用场景来说，牺牲一点性能来极大减少代码行数，或者说提高开发效率都是值得的。

interface 是 Golang 的一种重要的特性，但是这是以 runtime 为代价的，也就意味着性能的损失（关于 interface 的底层实现可以参考 Go Interface 源码剖析）。抛开性能不谈（现实中使用 Golang 开发的程序 99% 性能都不是问题），interface 对于如何设计我们的代码确实给了一个很好的思考。

如果大家学习过Java、C#的话，一定知道装箱(boxing)和拆箱(unboxing)两个概念，这个概念也可以用在这里。 接口变量中包含了(type, value)两个数据。装箱就是给type, value赋值，拆箱就是把value取出来。

我们还应该避免使用interface类型, 它需要在序列化和反序列化时做一些额外的处理。在一些动态调用的场景中，运行时调用也会增加一些额外 开销。编译器无法将这些调用替换为内联调用。

interface 底层实现的时候会动态的检测。同时这样也会引入一些问题：性能下降。使用 interface 作为函数参数，runtime 的时候会动态的确定行为。而使用 struct 作为参数，编译期间就可以确定了。

一般来说，最好避免依靠反射和interface，而是编写使用的具体类型。不幸的是，这往往导致很多重复的代码，所以最好以抽象的这个代码生成。


## ##

乍一看，人们会认为defer明可能会被编译器完全优化掉。如果我只是在函数的开头使用了defer语句，编译器确实可以通过在每一个return语句之前插入defer内容来实现。但是实际情况往往更复杂。比如，我们可以在条件语句或者循环中添加defer。第一种情况可能需要编译器找到应用defer语句的条件分支. 编译器还需要检查panic的情况，因为这也是函数退出执行的一种情况。通过静态编译提供这个功能（defer）似乎（至少从表面上看）是不太可能的。

    derfer并不是一个零成本的关键字，我们可以通过性能测试来看一下。在下面的测试中，我们对比了一个互斥锁在循环体中加锁后，直接解锁以及使用defer语句解锁的情况。

BenchmarkMutexDeferUnlock-8 20000000 96.6 ns/op
BenchmarkMutexUnlock-8 100000000 19.5 ns/op

    使用defer几乎慢了5倍。平心而论，77ns也许并不那么重要，但是在一个循环中它确实对性能产生了影响。通常要由开发者在性能和代码的易读性上做权衡。优化从来都是需要成本的。



## ##

Reflection通常是缓慢的，应当避免在延迟敏感的服务中使用。JSON是一种常用的数据交换格式，但Go的encoding/json库依赖于反射来对json进行序列化和反序列化。使用ffjson(译者注：easyjson会更快)，我们可以通过使用代码生成的方式来避免反射的使用，下面是性能对比。

## ##



Channel在Go语言中受到了很多的关注，因为它是一个方便的并发工具，但是了解它对性能的影响也很重要。在大多数场景下它的性能已经“足够好”了，但是在某些延时敏感的场景中，它可能会成为瓶颈。Channel并不是什么黑魔法。在Channel的底层实现中，使用的还是锁。在没有锁竞争的单线程应用中，它能工作的很好，但是在多线程场景下，性能会急剧下降。我们可以很容易的使用无锁队列ring buffer来替代channel的功能。