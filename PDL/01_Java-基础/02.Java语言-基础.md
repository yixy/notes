# Java语言-基础

## 1.类与对象

一个Java程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。对于一类对象而言，我们为了方便将它们归类起来，提取出他们相同的属性和行为，而我们把归类出来的这个抽象的概念，称之为类。

* 类(class)：类是相同或相似对象的一种抽象，是对象的一个模板，它描述一类对象的行为和状态。
* 对象(object)：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。
* 方法(method)：方法就是行为，一个对象可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。
* 属性(property)：每个类可以有多个属性变量，属性是对象具有的特征，用于描述对象的状态。

在Java中，类的实例化指由类创建对应的对象，一共有四种途径：

* 使用new操作符
* 调用Class对象的newInstance()方法
* 调用clone()方法，对现有实例的拷贝
* 通过ObjectInputStream的readObject()方法反序列化类

## 2.抽象

抽象，简单的理解就是对类内部细节的隐藏。在Java中，抽象即通过提供接口调用的方式，来屏蔽内部实现细节，这也是计算机系统中随处可见的思想。最常见的常见是，一个对象中的属性不允许其它对象直接访问，其它对象只能通过调用这个对象的公共接口的方式对其属性进行操作。

## 3.派生类：extends

Java中，一个类只能有一个父类，即类的单继承，使用 extends 关键字，这个类，称为派生类或子类。

继承可以让子类直接拥有父类的所有属性和方法(private的属性和方法不能被继承)。在 Java 中一个类只有一个父类，所以 Java 中的继承是单继承。继承的初始化顺序是先初始化父类再初始化子类。系统先创建了父类对象，再创建了子类对象，先初始化了属性，再调用了构造函数。

注意，基本类型（int,double,char…），数组类型和final类型的类不允许被继承。

***关键字：this***

编译器在调用某个实例方法时，实际上会把当前的实例对象的引用作为第一个参数传递给方法（可以通过class字节码文件反编译验证）。

* this.属性操作当前对象的属性
* this.方法调用当前对象的方法。

***关键字：supper***

如果子类在继承父类的非私有的法和成员变量时，没有同名的方法和变量可以直接通过名称使用父类的方法和变量。如果子类存在与父类同名的方法和成员变量时，要想区别访问父类和自身的变量和方法，需要使用 super 关键字调用父类变量和方法。注意，super.method并不会实例化一个父类的对象来调用对应方法。

* super.属性名 访问父类的属性
* super.方法 访问父类的方法

***关键字：final***

final关键字可以修饰类、方法、属性和变量。

* final 修饰类，则该类不允许被继承
* final 修饰方法，则该方法不允许被覆盖（重写）
* final 修饰属性：则该类的属性不会进行隐式的初始化（类的初始化属性必须有值）或在构造方法中赋值（但只能选其一）
* final 修饰变量，则该变量的值只能赋一次值，即变为常量

**重写**

虽然子类可以继承父类的方法，但如果子类对父类的方法不满意，子类想在里面加入适合自己的一些操作时，我们就需要将方法进行重写。并且子类在调用方法中，优先调用子类的方法。当然在方法重写时我们需要注意，重写的方法一定要与原父类的方法语法保持一致，比如返回值类型，参数类型及个数，和方法名都必须一致。

## 4.接口(interface)：extends

Java中并不允许多置继承，但Java提供了接口（interface）来解决这类问题。接口用关键字interface来定义，而不是class。一个类可以实现多个接口，但只能继承一个父类，接口可以继承多接口。一个类要实现某个或某几个接口的使用implements关键字。

## 5.抽象类(abstract)

抽象类是约束子类必须要实现哪些方法，而并不关注方法如何去实现。因为在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。抽象类在定义类时，前面会加abstract关键字。

抽象类和接口有类似之处，都不能用于创建对象，接口中的方法其实都是抽象方法。如果抽象类中只定义了抽象方法，那抽象类和接口就更像了。但抽象类和接口根本上是不同的，一个类可以实现多个接口，但只能继承一个类。**抽象类和接口是配合而非替代关系，它们经常一起使用，接口声明能力，抽象类提供默认实现，实现全部或部分方法，一个接口经常有一个对应的抽象类。**

接口的目的是指明相关或者不相关类的多个对象的共同行为，跟抽象类很相似，可以说接口是更加抽象的抽象类。接口中的所有方法都是抽象的，而抽象类可以有抽象方法，也可以有实例方法。接口与实现它的类不构成继承体系，即接口不是类体系的一部分。因此，不相关的类也可以实现相同的接口，而抽象类是属于类的继承体系，并且一般位于类体系的顶层。

* 用 abstract 修饰符定义抽象类
* 用 abstract 修饰符定义抽象方法，只用声明，不需要实现
* 包含抽象方法的类就是抽象类
* 抽象类中可以包含普通的方法，也可以没有抽象方法
* 抽象类的对象不能直接创建，我们通常是定义引用变量指向子类对象。

抽象类的派生类，必须重写所有的抽象方法。

## 6. 内部类

内部类（ Inner Class ）就是定义在另外一个类里面的类，而包含内部类的类被称为外部类。

作为一个类的编写者，我们很显然需要**对类的使用访问者的访问权限做出一定的限制**，我们需要将一些我们不愿意让别人看到的操作隐藏起来，如果我们的内部类不想轻易被任何人访问，可以选择使用private修饰内部类，这样我们就无法通过创建对象的方法来访问，想要访问只需要在外部类中定义一个public修饰的方法，间接调用。

> 内部类可以解决继承及实现接口出现同名方法的问题。

成员内部类相当于外部类的一个成员变量。

* Student 类相当于 People 类的一个成员变量，所以 Student 类可以使用任意访问修饰符
* Student 类在 People 类里，所以访问范围在类里的所有方法均可以访问 People 的属性（即内部类里可以直接访问外部类的方法和属性，反之不行）
* 定义成员内部类后，必须使用外部类对象来创建内部类对象，即 内部类 对象名 = 外部类对象.new 内部类();
* 如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字

静态内部类是 static 修饰的内部类。

* 静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问
* 如果外部类的静态成员与内部类的成员名称相同，可通过类名.静态成员访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过成员名直接调用外部类的静态成员
* 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类();

方法内部类就是定义在外部类的方法中的内部类。

* 方法内部类只在该方法的内部可见，即只在该方法内可以使用。

### 7.多态

多态是指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。Java中的多态使用动态绑定实现。 **接口的引用可以指向实现类的对象，通过在实现类中实现接口的方法，实现多态；父类的引用可以指向子类的对象，通过在子类中重写父类方法，实现多态。** 注意，不能使用一个子类的引用去指向父类的对象。

> 动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。

通常使用抽象类的引用指向其派生子类来实现多态。

> Java中主要有三个地方涉及到多态：类继承，接口实现，泛型。Java的类继承的多态特性不显著，因为很大程度上都会先定义接口，而不是依靠基类进行多态，类继承整体上来说只是复用代码的手段Java的泛型在多态上是个残废，它不像C++模板那样允许依靠编译时生成代码的方式进行不依赖类型继承的多态，如果希望泛型类型参数参与多态，它必须也被定义为实现了某个特定的接口。所以Java根本就是只有接口实现是多态特性，所以你看Java里面为什么interface满天飞，天天重构继承和接口实现关系，Java的多态就是个大坑。对比C++，C++支持多继承，所以类继承就可以替代Java的接口，整体上来说更灵活一些（也更容易弄出错误的设计）；但C++同时还支持模板，这个对于多态来说作用是非常大的，像STL当中的多种容器的iterator，从来不要求从一个公共的基类里派生出来，但是它们都可以用于algorithm中的各种算法，颇有一些duck type的意思。C++还有一种容易被忽视的多态特性，是继承自C的，也就是函数指针，以及指向成员函数的指针，通过将函数指针指向不同的函数，就可以实现相同的代码调用不同实现，MFC等框架当中有重要的作用。所以你没法说C++中最能体现多态的是继承、虚函数还是模板，都会有争议。(作者：灵剑 链接：https://www.zhihu.com/question/48023110/answer/127269604)

## 8. 基本类型和API

Java的基本类型都是值传递类型。

java.lang是基本数据类型的包装类。在程序中，java.lang 包并不需要像其他包一样需要import关键字进行引入。系统会自动加载，所以我们可以直接取用其中的所有类。

* byte（字节） Byte
* char（字符） Character
* int（整型） Integer
* long （长整型） Long
* float（浮点型） Float
* double （双精度） Double
* boolean （布尔） Boolean
* short（短整型） Short

java.util 包提供了一些实用的方法和数据结构。比如日期类 Data，日历类 Calendar 以及随机数类 Random，同时包里还提供了堆栈 Stack、向量 Vector、位集合 Bitset 以及哈希表 Hashtable等表示数据结构的类。

## 9. 异常处理

Java中的异常都是从Throwable类派生出来的，而Throwable类是直接从Object类继承而来。

* Error：系统内部错误，这类错误由系统进行处理，程序本身无需捕获处理
* Exception：可以处理的异常
* RuntimeException：可以捕获，也可以不捕获的异常
* 继承Exception的其他类：必须捕获，通常在API文档中会说明这些方法抛出哪些异常

Java的异常处理机制要求，把可能发生错误或出现问题的语句放到try语句块中，将异常发生后要执行的语句放到catch语句块中，而finally语句块里面放置的语句，不管异常是否发生，它们都会被执行。

## 10. 垃圾回收

在Java中，垃圾回收机制就是通过一个线程在后台实现的，这样做的好处在于：开发者通常不需要为内存管理投入太多的精力。



