# 基础——GC #


# 内存分配原理 #

## 1 

Go 有两个地方可以分配内存：一个全局堆空间用来动态分配内存，另一个是每个 goroutine 都有的自身栈空间。

    栈区的内存一般由编译器自动进行分配和释放，其中存储着函数的入参以及局部变量，这些参数会随着函数的创建而创建，函数的返回而销毁。(通过 CPU push & release)。


    堆区的内存一般由编译器和工程师自己共同进行管理分配，交给 Runtime GC 来释放。堆上分配必须找到一块足够大的内存来存放新的变量数据。后续释放时，垃圾回收器扫描堆空间寻找不再被使用的对象。


栈分配廉价，堆分配昂贵。


变量是在堆还是栈上？

写过其他语言，比如 C 的同学都知道，有明确的栈和堆的相关概念。而 Go 声明语法并没有提到栈和堆，而是交给 Go 编译器决定在哪分配内存，保证程序的正确性，在 Go FAQ 里面提到这么一段解释：


    从正确的角度来看，你不需要知道。Go 中的每个变量只要有引用就会一直存在。变量的存储位置(堆还是栈)和语言的语义无关。
    存储位置对于写出高性能的程序确实有影响。如果可能，Go 编译器将为该函数的堆栈侦(stack frame)中的函数分配本地变量。但是如果编译器在函数返回后无法证明变量未被引用，则编译器必须在会被垃圾回收的堆上分配变量以避免悬空指针错误。此外，如果局部变量非常大，将它存储在堆而不是栈上可能更有意义。
    在当前编译器中，如果变量存在取址，则该变量是堆上分配的候选变量。但是基础的逃逸分析可以将那些生存不超过函数返回值的变量识别出来，并且因此可以分配在栈上。


逃逸分析

一是 go build -gcflags '-m'

二是 go tool pprof 进行压测，分析内存分配情况

还存在大量其他的 case 会出现逃逸，比较典型的就是 “多级间接赋值容易导致逃逸”，这里的多级间接指的是，对某个引用类对象中的引用类成员进行赋值（记住公式 Data.Field = Value，如果 Data, Field 都是引用类的数据类型，则会导致 Value 逃逸。这里的等号 = 不单单只赋值，也表示参数传递）。Go 语言中的引用类数据类型有 func, interface, slice, map, chan, *Type ：

一个值被分享到函数栈帧范围之外
在 for 循环外申明，在 for 循环内分配，同理闭包
发送指针或者带有指针的值到 channel 中
在一个切片上存储指针或带指针的值
slice 的背后数组被重新分配了
在 interface 类型上调用方法
.... go build -gcflags '-m'







Go 应用程序运行时，每个 goroutine 都维护着一个自己的栈区，这个栈区只能自己使用不能被其他 goroutine 使用。栈区的初始大小是2KB(比 x86_64 架构下线程的默认栈2M 要小很多)，在 goroutine 运行的时候栈区会按照需要增长和收缩，占用的内存最大限制的默认值在64位系统上是1GB。
v1.0 ~ v1.1 — 最小栈内存空间为 4KB
v1.2 — 将最小栈内存提升到了 8KB
v1.3 — 使用连续栈替换之前版本的分段栈
v1.4 — 将最小栈内存降低到了 2KB



Go语言的自动圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。
因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。
编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。

## 1. 使用GODEBUG分析GC ##

可以通过在go run 或 go test前使用GODEBUG=gctrace=1来输出GC信息。

```
GODEBUG=gctrace=1 go run main.go
GODEBUG=gctrace=1 go test main.go
```

![golang-gc](http://sweeat.me/golang-gc.png)

## 2. 使用trace分析 ##

go test中的trace参数可以用于分析GC，也可以分析processor的状况。

```
//测试程序输出trace信息
go test -trace trace.out

//可视化trace信息
go tool trace trace.out
```

可以通过在源码中调用API的方式，生成更细粒度的trace文件。

```
trace.Start
trace.Stop
```

## 3. GC友好的代码 ##

* 复杂对象尽量传递其指针，如数组、结构体等
* 自动扩容是有代价的，如slice，应初始化至合适大小
* 复用内存


## 参考 ##

https://godoc.org/runtime

参考Goruntime。