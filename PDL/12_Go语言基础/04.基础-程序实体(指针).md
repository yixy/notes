# 基础——程序实体(指针) #

Go 具有指针，指针保存了变量的内存地址。但是注意Golang的指针是单独的类型，而不像C语言中的int类型，而且也不能对Golang的指针做整数运算。

* Golang的指针不支持指针运算

Go语言所有类型都是值传递。但是注意以下类型虽然为值传递，但是由于包含指针，有类似引用的副作用：

* 切片：切片内部有指向数组的指针，可以改变所指向的数组元素。
* map：本质上是一个字典指针。
* channel：和map类似，也是一个指针。
* interface：接口具备引用语义，是因为其内部也维持了两个指针。

类型 * T 是指向类型 T 的值的指针。其零值是 `nil`。& 符号会生成一个指向其作用对象的指针。* 符号表示指针指向的底层的值。与 C 不同，Go 没有指针运算。

```
i := 42
p = &i
fmt.Println(* p) // 通过指针 p 读取 i
* p = 21         // 通过指针 p 设置 i
```

任何类型的指针的零值都是nil。如果p != nil测试为真，那么p是指向某个有效变量。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。

## 性能相关的问题 ##

指针是否会对性能产生负面影响？主要出于两方面的考量：

* 解引用虽然耗能很小，但积少成多，不得不虑。
* 通过指针共享的数据，是放在堆上的。堆数据的清理是GC负责的，这也会产生开销。随着堆上数据增多，GC的工作量变大，对项目的性能影响也不容忽视。

指针可以节省复制的开销，但同时要考虑解引用和垃圾回收带来的影响。性能分析结果显示复制是瓶颈之前，不应该考虑把指针作为优化方案。计算机在复制方面的速度可是极快的。

