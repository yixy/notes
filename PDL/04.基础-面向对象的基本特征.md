# 面向对象的基本特征

## 0. 误区：OOP的三大特征

经常可以看到这样的说法，面向对象编程（OOP)的基本特征有三个：抽象（封装）、继承、多态。

OOP=抽象（封装）+继承+多态 的这个提法是不准确的，把原本很容易理解的，直观的做事方法变的图腾化。初学者往往会觉得他们听上去很厉害，但是使用起来又经常和现实相冲突以至于落不了地。

下面先简单介绍下抽象封装、继承、多态。

* 抽象（封装）：封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项，或者叫接口。有了封装，就可以明确区分内外，使得类实现者可以修改封装内的东西而不影响外部调用者；而外部调用者也可以知道自己不可以碰哪里。这就提供一个良好的合作基础——或者说，只要接口这个基础约定不变，则代码改变不足为虑。
* 继承+多态：继承和多态，任何时候都不应该把这两个概念拆开来看，这两个事情合起来才是和“封装”等价的。继承是为了实现接口的复用，声明某个子类兼容于某基类（或者说，接口上完全兼容于基类），外部调用者可无需关注其差别（内部机制会自动把请求派发[dispatch]到合适的逻辑）。多态实现了基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。当你用继承的时候，肯定是需要利用多态的特性。如果用不到多态的特性，继承的关系是无用的。所以如果一旦将继承和多态割裂，就说明理解上已经误入歧途了。多态实质上是继承的实现细节；那么让多态与封装、继承这两个概念并列，显然是不符合逻辑的。不假思索的就把它们当作可并列概念使用的人，显然是从一开始就被误导了——正是这种误导，使得大多数人把注意力过多集中在多态这个战术层面的问题上，甚至达到近乎恶意利用的程度；同时却忽略了战略层面的问题，这就致使软件很容易被他们设计成shit mountain。

## 1. 到底什么是OOP

OOP应该是一种编程思想，而不是具体的编程语言。

* OOP应该体现一种网状结构，这个结构上的每个节点“Object”只能通过“消息”和其他节点通讯。每个节点会有内部隐藏的状态，状态不可以被直接修改，而应该通过消息传递的方式来间接的修改。

> I thought of objects being like biological cells and/or individual computers on a network, only able to communicate with messages (so messaging came at the very beginning -- it took a while to see how to do messaging in a programming language efficiently enough to be useful)....OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things. It can be done in Smalltalk and in LISP.

## 2. 抽象（封装）

面向对象的抽象，通常也被称为封装，是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的“高内聚、低耦合”，防止程序相互依赖性而带来的变动影响。面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。“封装”这并不是OOP发明的，而是长久以来一直被广泛采用的方法。

* 面向对象的抽象（封装）性：数据和行为的抽象，即将对象抽象（封装）成一个高度自治和相对封闭的个体，对象状态（属性）由这个对象自己的行为（方法）来读取和改变。

许多程序设计语言，使用类来进行数据抽象封装，比如Java、C++。对象之间通过方法调用，互相之间屏蔽内部细节。

## 3. 代码复用：组合与继承

组合和继承都是为了实现代码的复用。但是两者存在显著的区别。一般的，***在建新类时，应该首先考虑组合，因为它更加简单灵活。而一般对于需要利用多态的场景才使用继承。***下面分别介绍组合和继承。

* 组合：希望通过类型的 has-a 关系实现代码的复用。

简单的说，就是一个类里面有另一个类的一个引用，就是组合关系了。这个时候可以说“class-A has a class-B”。组合的耦合度相对小很多，只要类里的接口不变，一般不会出现继承里的一处改处处改的问题。毕竟，你是通过另一个类的引用调用其中的一些方法（函数）而已。

* 继承：希望通过类型的 is-a 关系来实现接口的复用。

许多程序设计语言都有类的概念，并且支持类派生从一个类继承另一个类，前者称为派生类（或子类），后者称为基类（或父类）。子类继承父类的成员和方法。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。

继承是为了实现接口的复用，声明某个子类兼容于某基类（或者说，接口上完全兼容于基类），外部调用者可无需关注其差别（内部机制会自动把请求派发[dispatch]到合适的逻辑）。其实在《Thinking in java》里有提到，当你用继承的时候，肯定是需要利用多态的特性。**如果用不到多态的特性，继承的关系是无用的。**而用不到多态的时候，继承有什么用呢？代码复用？一个继承可以让你少写很多代码，但是用错了场合，后期的维护可能是灾难性的。因为继承关系的耦合度很高，一处改会导致处处需要修改。这个时候就需要组合。

所以，实际上继承并不是面向对象的优势，由于继承带来了基类与子类的强关系，使得类之间的关系更加复杂，限制条件更多：当基类发生变动时，子类也会反映出这些变动。

## 4. 多态

多态可以使程序员写出不依赖特定类型的代码。多态性增强了软件的灵活性和扩展性。

* 同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。

在静态绑定中，函数调用在编译时就已经确定了，而在动态绑定中，函数调用在运行时才会确定。在介绍多态的实现方式前先介绍“静态绑定与动态绑定”、“方法重载与方法重写”的概念。

###### 静态绑定与动态绑定

Java中动态绑定是默认的，而C++中则需要使用virtual关键字声明。

* 静态绑定：指在编译时判断所引用对象的实际类型，根据其实际的类型绑定其相应的方法。
* 动态绑定：指在运行时（执行期间）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。程序运行过程中，把函数（或过程）调用与响应调用所需要的代码相结合的过程称为动态绑定。

###### 方法重载与方法重写

* 重载（Overload）：函数或者方法具有相同的名称，但是参数列表不相同（类型或个数不同），这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。
* 重写（Override）：又称方法覆盖，指子类继承父类，但在子类中重新定义继承自父类的方法。此时，父类与子类有同样的方法名和参数。

**Java和C++这样的基于继承的体系，使用方法重写和动态绑定实现多态。具体的说，即当父类引用指向子类对象，调用方法时会调用子类的实现，而不是父类的实现。**

```Java
//Overload
void foo(String str);
void foo(int number);
//Override
//父类与子类有同样的方法名和参数，这叫方法覆盖。
class Parent {
    void foo() {
        System.out.println("Parent foo()");
    }
}
class Child extends Parent {
    void foo() {
        System.out.println("Child foo()");
    }
}
```

Golang不支持继承，使用接口实现多态。在Go语言中，接口（interface）的实现是通过动态绑定实现的。虽然Go是静态类型语言，但是它的接口是动态绑定的。这意味着编译器不会在编译时确定接口方法的具体实现，而是在运行时根据对象的实际类型来确定调用的方法。因此，Go语言的接口可以被视为一种动态多态的实现。
