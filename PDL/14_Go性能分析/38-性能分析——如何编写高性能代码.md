# 性能分析——如何编写高性能代码 #

## 1. 性能指标 ##

* Wall Time：墙上时钟时间，程序运行的绝对时间（包括程序阻塞时间）
* CPU Time：
* 内存分配

## 2. 别让性能被锁住 ##

即使是使用读锁，仍然是有性能开销的。有锁和无锁可能有一个数量级差别（10+ms和100+ms）。

* 减少锁影响的范围：能不用锁的地方就不用
* 减少锁冲突的概率：读多写少用sync.Map；写多读少/写多读多用concurrent_map（`https://github.com/easierway/concurrent_map`）
* 不使用锁：例如使用LAMX Disruptor

https://tech.meituan.com/2016/11/18/disruptor.html

## 3. GC友好的代码 ##

核心思路是尽量避免内存的分配和复制。

* 复杂对象尽量传递指针：大数组传递、大结构体传递
* 初始化至合适的大小：太小的话，自动扩容是有代价的（slice）；太大的话，利用率低，增加额外性能开销（如对象拷贝、GC）。
* 高性能字符串连接：避免反复申请内存，StringBuilder
* 复用内存

## ##

仔细分析之后可以得到一个大概结论，reflect慢主要有两个原因：一是涉及到内存分配以后GC；二是reflect实现里面有大量的枚举，也就是for循环，比如类型之类的。

因为反射中使用了类型的枚举，所以效率比较低，在高性能场景中应该尽量规避，但是，对于大部分应用场景来说，牺牲一点性能来极大减少代码行数，或者说提高开发效率都是值得的。

interface 是 Golang 的一种重要的特性，但是这是以 runtime 为代价的，也就意味着性能的损失（关于 interface 的底层实现可以参考 Go Interface 源码剖析）。抛开性能不谈（现实中使用 Golang 开发的程序 99% 性能都不是问题），interface 对于如何设计我们的代码确实给了一个很好的思考。

如果大家学习过Java、C#的话，一定知道装箱(boxing)和拆箱(unboxing)两个概念，这个概念也可以用在这里。 接口变量中包含了(type, value)两个数据。装箱就是给type, value赋值，拆箱就是把value取出来。

我们还应该避免使用interface类型, 它需要在序列化和反序列化时做一些额外的处理。在一些动态调用的场景中，运行时调用也会增加一些额外 开销。编译器无法将这些调用替换为内联调用。

interface 底层实现的时候会动态的检测。同时这样也会引入一些问题：性能下降。使用 interface 作为函数参数，runtime 的时候会动态的确定行为。而使用 struct 作为参数，编译期间就可以确定了。

一般来说，最好避免依靠反射和interface，而是编写使用的具体类型。不幸的是，这往往导致很多重复的代码，所以最好以抽象的这个代码生成。


## ##

乍一看，人们会认为defer明可能会被编译器完全优化掉。如果我只是在函数的开头使用了defer语句，编译器确实可以通过在每一个return语句之前插入defer内容来实现。但是实际情况往往更复杂。比如，我们可以在条件语句或者循环中添加defer。第一种情况可能需要编译器找到应用defer语句的条件分支. 编译器还需要检查panic的情况，因为这也是函数退出执行的一种情况。通过静态编译提供这个功能（defer）似乎（至少从表面上看）是不太可能的。

    derfer并不是一个零成本的关键字，我们可以通过性能测试来看一下。在下面的测试中，我们对比了一个互斥锁在循环体中加锁后，直接解锁以及使用defer语句解锁的情况。

BenchmarkMutexDeferUnlock-8 20000000 96.6 ns/op
BenchmarkMutexUnlock-8 100000000 19.5 ns/op

    使用defer几乎慢了5倍。平心而论，77ns也许并不那么重要，但是在一个循环中它确实对性能产生了影响。通常要由开发者在性能和代码的易读性上做权衡。优化从来都是需要成本的。



## ##

Reflection通常是缓慢的，应当避免在延迟敏感的服务中使用。JSON是一种常用的数据交换格式，但Go的encoding/json库依赖于反射来对json进行序列化和反序列化。使用ffjson(译者注：easyjson会更快)，我们可以通过使用代码生成的方式来避免反射的使用，下面是性能对比。

## ##



Channel在Go语言中受到了很多的关注，因为它是一个方便的并发工具，但是了解它对性能的影响也很重要。在大多数场景下它的性能已经“足够好”了，但是在某些延时敏感的场景中，它可能会成为瓶颈。Channel并不是什么黑魔法。在Channel的底层实现中，使用的还是锁。在没有锁竞争的单线程应用中，它能工作的很好，但是在多线程场景下，性能会急剧下降。我们可以很容易的使用无锁队列ring buffer来替代channel的功能。








## 性能相关的问题 ##

指针是否会对性能产生负面影响？主要出于两方面的考量：

* 解引用虽然耗能很小，但积少成多，不得不虑。
* 通过指针共享的数据，是放在堆上的。堆数据的清理是GC负责的，这也会产生开销。随着堆上数据增多，GC的工作量变大，对项目的性能影响也不容忽视。

指针可以节省复制的开销，但同时要考虑解引用和垃圾回收带来的影响。性能分析结果显示复制是瓶颈之前，不应该考虑把指针作为优化方案。计算机在复制方面的速度可是极快的。



## slice的底层数组变动会影响slice


## map的key不能是函数、slice、map、channel

 Go 语言字典的键类型不可以是函数类型、字典类型和切片类型。因为Go 语言的字典类型其实是一个哈希表（hash table）的特定实现，因为hash值有可能相同，在这种情况下需要使用原来的key去做比较，所以map的key只能是任意定义了==与!=操作的类型。
* 注意，如果键的类型是接口类型或是数组类型，那么键的实际（元素）类型也不能是函数类型、字典类型和切片类型，否则在程序运行过程中会引发 panic。


## 2. 非线程安全的Map & sync.Map & concurrent_map ##


## 3. GC友好的代码 ##

GOGC的实现方式。

* 复杂对象尽量传递其指针，如数组、结构体等
* 限制Goroutine数量，控制内存分配的速度。
* 尽量不使用+去连接字符串。
* 自动扩容是有代价的，如slice，应初始化至合适大小。
* 避免小对象过多，降低扫描时间。如map的key对象不要过多。
* 复用变量，尽量少分配对象。
* 临时方案（应急）：降低GC触发频率。



https://www.cnblogs.com/sunsky303/p/11077030.html
https://swsmile.info/post/golang-pprof-memory-profiling/
https://blog.xizhibei.me/2021/06/27/golang-heap-profiling/
https://cloud.tencent.com/developer/article/1489186
https://colobu.com/2019/08/20/use-pprof-to-compare-go-memory-usage/


https://blog.cyeam.com/golang/2018/09/27/athens


http连接：
https://segmentfault.com/a/1190000023676010



# 值传递


（Golang中具备引用传递特征的类型实际上也是值传递，其类似引用传递的效果都源于指针：）

* 切片：切片内部有指向数组的指针，可以改变所指向的数组元素。
* map：本质上是一个字典指针。
* channel：和map类似，也是一个指针。
* interface：接口具备引用语义，是因为其内部的结构体也维持了两个指针。（指向类型和值）

**与C 系列中的所有语言一样，Go 中的所有内容都是按值传递的。** 也就是说，一个函数总是得到一个被传递的东西的副本，就好像有一个赋值语句给参数赋值一样。例如，将 int 值传递给函数会生成 int 的副本，而 **传递指针值会生成指针的副本，但不会生成指针指向的数据的副本** 。

**map、slice、chan的行为类似于指针：它们是包含指向底层数据的指针的描述符。** 复制map、chan和slice不会复制它指向的数据。

**复制interface值会复制接口对应的结构体（结构体有指向类型和数据的指针）。但interface因为接口本身对机制原因，使用时稍微有些区别。** 对于空接口形参，如果要访问接口对象需要做类型推断，此时会拷贝新的值；对于非空接口形参，如果要访问接口对象，只能通过接口实现的方法来访问（此时receiver是指针类型还是非指针类型效果不同）。所以，虽然接口作为传参有两个指针，但接口值是非指针时，仅能对副本操作；接口值时指针时，可以直接对原始数据进行操作。

## 性能相关的问题 ##

指针是否会对性能产生负面影响？主要出于两方面的考量：

* 解引用虽然耗能很小，但积少成多，不得不虑。
* 通过指针共享的数据，是放在堆上的。堆数据的清理是GC负责的，这也会产生开销。随着堆上数据增多，GC的工作量变大，对项目的性能影响也不容忽视。

指针可以节省复制的开销，但同时要考虑解引用和垃圾回收带来的影响。性能分析结果显示复制是瓶颈之前，不应该考虑把指针作为优化方案。计算机在复制方面的速度可是极快的。

## slice的底层数组变动会影响slice


## map的key不能是函数、slice、map、channel

 Go 语言字典的键类型不可以是函数类型、字典类型和切片类型。因为Go 语言的字典类型其实是一个哈希表（hash table）的特定实现，因为hash值有可能相同，在这种情况下需要使用原来的key去做比较，所以map的key只能是任意定义了==与!=操作的类型。
* 注意，如果键的类型是接口类型或是数组类型，那么键的实际（元素）类型也不能是函数类型、字典类型和切片类型，否则在程序运行过程中会引发 panic。


## 2. 非线程安全的Map & sync.Map & concurrent_map ##


## 3. GC友好的代码 ##

GOGC的实现方式。

引用计数（Reference Counting）的基本原理是为每个对象维护一个计数器，用来记录有多少个引用指向这个对象。这种方式存在循环引用问题，引用计数机制无法检测到循环引用。即如果两个或多个对象互相引用，尽管它们不再被其他对象引用，它们的引用计数永远不会降到0，导致内存泄漏。每次引用的增加或减少都需要更新计数器，这增加了额外的开销，尤其是在频繁引用或释放对象时。

标记-清除（Mark-and-Sweep）：原理：垃圾回收器首先遍历所有的根对象（即可以直接访问的对象），并标记所有可达的对象。接着，它扫描整个堆，回收未标记的对象。存在StopTheWorld的问题。

标记-压缩（Mark-and-Compact）：原理：类似于标记-清除，但在清除不可达对象之后，会对可达对象进行压缩，将它们移动到内存的一个连续区域，以减少内存碎片。

分代垃圾回收（Generational Garbage Collection）：优化了垃圾回收的性能，因为大多数垃圾回收发生在新生代中，减少了扫描和回收的开销。

复制回收（Copying Garbage Collection）
原理：将内存分为两个区域（From和To）。每次垃圾回收时，将可达对象从From区域复制到To区域，未复制的对象即被回收。
优点：简化了内存分配和回收，避免了内存碎片问题。
缺点：需要额外的内存空间来存储两个区域，可能会浪费内存。


* 复杂对象尽量传递其指针，如数组、结构体等
* 自动扩容是有代价的，如slice，应初始化至合适大小
* 复用内存