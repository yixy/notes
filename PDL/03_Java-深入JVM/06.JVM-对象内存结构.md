# JVM-对象内存结构

HotSpot 虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头 (Header)、实例数据 （Instance Data）和对齐填充 (Padding)。

> 可以使用Java对象布局查看工具JOL(Java Object Layout)查看内存布局。

## 1 对象头 (Header)

> 参考源码 markoop.cpp/markoop.h

> 注意，实际查看对象头的时候，需要注意hashcode是JVM的native方法获取的，另外还要考虑大端序/小端序。

**HotSpot 虛拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据：Mark Word**，如哈希码 （HashCode)、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间截等，这部分数据的长度在 32 位和 64 位的虛拟机（未开启压缩指针）中分别为 32bit 和64bit，官方称它为 “Mark Word”。对象需要存储的运行时数据很多，其实已经超出了 32位、64 位 Bitmap 结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如，在32位的HoSpot 虛拟机中，如果对象处于未被锁定的状态下，那么Mark Word 的 32bit 空间中的 25bit用于存储对象哈希码，4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为0。**对象头的另外一部分是类型指针，即对象指向它的类元数据的指针：klass pointer/Class Metadata Address，虚拟机通过这个指针来确定这个对象是哪个类的实例。（klass pointer，在没开启指针压缩时占64bit，开启指针压缩占32bit）**并不是所有的虚拟机实现都必领在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。另外，如果对象是一个Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。

## 2 实例数据 （Instance Data）

**实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。**无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虛拟机分配策略参数（FieldsAllocationstyle）和字段在Java 源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为 longs/doubles、intsn shorts/chars、 bytes/booleans、oops COrdinary Objeot Pointers)，从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields 参数值为 true（默认为 true），那么子类之中较窄的变量也可能会插人到父类变量的空隙之中。

## 3 对齐填充 (Padding)

第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于 HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，**当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。**

