# JVM-编译与代码优化-逃逸分析

## 1 什么是逃逸分析

逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。

逃逸分析指分析指针动态作用范围的方法，简单讲就是当一个对象的指针被多个方法或线程引用时，称这个指针发生了逃逸。逃逸是指逃出了当前代码块的作用域，被其他的代码块引用了。对象发生了逃逸，也就是被多个线程或方法共享了，那么这个对象必定要分配到能够被线程共享的内存区域，否则这个对象无法被其他线程读取使用。在JVM内存模型中，官方规定的被线程共享的内存模块有堆和元空间，而被用来存储对象的内存区域就是堆。

## 2 JVM对非逃逸对象的优化

如果对象不会发生前述方法逃逸和线程逃逸情况（即完全不可能被别的方法和线程访问到的对象），JVM 可做以下优化：

* 栈上分配：普通对象在堆中分配，各线程共享。但有 GC 消耗。当确定对象不会发生方法逃逸时，可在线程栈上分配对象。此时对象生命周期和方法相同，随栈帧出栈时即可销毁，不需要 GC 了。
* 同步消除：线程同步有性能消耗。1）锁消除：当确定对象不会发生线程逃逸时，可消除该对象不必要的同步操作（永不会竞争）。具体来说，JVM 在编译器运行时会扫描代码，当检查到那些不可能存在共享区竞争，但却有互斥同步的代码，直接将这样的多此一举的同步消除。2）锁粗化：JVM 针对那些反复在一段代码中对同一对象加锁的情况，将同步锁放在最外层包住这里面的多次同步锁，同时取消内部的同步锁
* 标量替换：如果一个可拆分对象不会发生逃逸，那在程序执行时并不创建他，而是根据情况在线程栈上只创建用到的成员标量。

## 3 相关参数配置

逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态。

逃逸分析的 JVM 参数如下：

* 开启逃逸分析：-XX:+DoEscapeAnalysis
* 关闭逃逸分析：-XX:-DoEscapeAnalysis
* 显示分析结果：-XX:+PrintEscapeAnalysis

```
public class App{
    public static void main(String[] args){
        while(true){
        //未逃逸对象，在Java栈分配，不需要GC
        Integer integer=new Integer(111111111);
        }
    }
}
```
