# JMM-内存模型

## 1 JMM抽象

JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器和处理器重排序等特性，为程序员提供一致的内存可见性保证。

在 java 中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java 语言规范称之为 formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。

Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在**主内存（main memory）**中，每个线程都有一个私有的**本地内存（local memory）**，本地内存中存储了该线程以读 / 写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。

## 2 JMM内存操作规则

关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下8种操作来完成。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load store、read和write操作在某些平合上允许有例外）：

* lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
* unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
* sread（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
* load (载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
* use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
* assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
* store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
* write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。

如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和1oad操作，如果要把变量从工作内存同生回主内存，就要按顺序执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。也就是说read与load之 间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，种可能出现的顺序是read a、read b、load b、1oad a。除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：

* 不允许read 和load、store 和write 操作之一单独出现，即不允许一个交量从主内在读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。
* 不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
* 不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。
* 一个新的变量只能在主内存中 “诞生”，不允许在工作内存中直接使用一个未被初始化 （load 或assign）的变量，换句话说，就是对一个变量实施 use、store 操作之前，必须先执行过了 assign 和 load 操作。
* 一个变量在同一个时刻只允许一条线程对其进行 lock操作，但 lock 操作可以被同一条线程重复执行多次，多次执行lock 后，只有执行相同次数的unlock操作，变量才会被解锁。
* 如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。
* 如果一个变量事先没有被 1ock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。
* 对一个变量执行 unlock 操作之前，必领先把此变量同步回主内存中（执行 store、 write操作）。

volatile关键字特殊规则：

* 保证变量对所有线程的可见性：当线程修改变量值时，该变量对所有线程立即可见。
* 禁止代码重排序。

注意，除了volatile关键字外，synchronized（一个变量在同一时刻仅允许一个线程对其进行lock）和final（被final修饰的字段初始化完成后，且无this引用逃逸的情况下，其它线程都能看到final字段的值）也能用于实现可见性。

这8种内存访问操作以及上述规则限定，再加上对 volatile 的一些特殊规定，终完全确定了 Java 程序中哪些内存访问操作在并发下是安全的。

## 3 Java天然的先行发生规则

下面是 Java 内存模型下一此“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。

Java 语言无任何同步手段保障就能成立的先行发生规则如下：

* 程序次序规则 (Program Order Rule)：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考感分支、循环等结构。
* 管程锁定规则 (Monitor Lock Rule)：一个unlock 操作先行发生于后面对同一个锁的lock 操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。
*  volatile 变量规则 (Volatile Variable Rule)：对一个volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。
* 线程启动规则 (Thread Start Rule)：Thread 对象的start0方法先行发生于此线程的每个动作。
* 线程终止规则 (Thread Termination Rule)：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread join0 方法结束、Thread.isAlive0 的返回值等手段检测到线程已经终止执行。
* 线程中断规则 (Thread Interruption Rule)：对线程 interrupt0 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interruptedo 方法检测到是否有中断发生。
* 对象终结规则 （Finalizer Rule)：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize0 方法的开始。
* 传递性 (Transitivity）：如果操作 A 先行发生于操作 B，操作B 先行发生于操作C,那就可以得出操作 A 先行发生于操作 C 的结论。
