# JVM-类加载机制

与那些在编译时需要进行连接工作的语言不同，在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。

![](https://raw.githubusercontent.com/yixy4app/images/picgo/202210081015920.png)

## 1 类加载过程

**类加载将Java类文件中的class字节码二进制数据读入到内存中，并将其放入运行时数据区的方法区内，最终在堆区中创建一个class对象。**

**JVM的类加载子系统支持在运行时的动态加载**，动态加载的优点有很多，例如可以节省内存空间、灵活地从网络上加载类，动态加载的另一好处是可以通过命名空间的分隔来实现类的隔离，增强了整个系统的安全性。

## 2 类的生命周期

Java类从被加载到虚拟机内存中开始，到卸载出内存为止，它的**整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using) 和 卸载(Unloading)七个阶段。其中验证、准备、解析3个部分统称为连接（Linking）。**

* 加载：(1)通过IO读入字节码文件，根据类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：ZIP包-JAR和WAR等格式的基础、网络-Applet、运行时动态生成-动态绑定、由其他文件生成-JSP、数据库-用于中间件服务器等）；(2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；(3)在内存中(对于HotSpot虚拟就而言就是方法区)生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；
* 连接-验证：确保被加载的类的正确性。验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 验证阶段大致会完成4个阶段的检验动作：文件格式验证；元数据验证；字节码验证；符号引用验证。验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响。如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。
* 连接-准备：为类的 静态变量分配内存，并将其初始化为默认值。准备阶段是正式为类变量(static 成员变量)分配内存并设置类变量初始值（零值）的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为`public static int value = 123;`，那么，变量value在准备阶段过后的值为0而不是123。
* 连接-解析：把类中的符号引用转换为直接引用。解析阶段(Resolution)是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。
* 初始化(Initialization)：类的静态变量初始化，执行静态代码块。类初始化阶段是类加载过程的最后一步。在前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类装载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的java程序代码(字节码)。在准备阶段，变量已经赋过一次系统要求的初始值(零值)；而在初始化阶段，则根据程序猿通过程序制定的主观计划去初始化类变量和其他资源，或者更直接地说：初始化阶段是执行类构造器`<clinit>()`方法的过程。

加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。以下陈述的内容都以HotSpot为准。特别需要注意的是，类的加载过程必须按照这种顺序按部就班地“开始”，而不是按部就班的“进行”或“完成”，因为这些阶段通常都是相互交叉地混合式进行的，也就是说通常会在一个阶段执行的过程中调用或激活另外一个阶段。

1. 什么时候进行加载？

虚拟机规范中并没有对此进行强制约束，这点可以交给虚拟机的具体实现来自由把握。

2. 什么时候进行初始化？

这在虚拟机规范中是有严格规定的，虚拟机规范指明 有且只有 五种情况必须立即对类进行初始化：

* 遇到new、getstatic、putstatic或invokestatic这四条字节码指令（注意，newarray指令触发的只是数组类型本身的初始化，而不会导致其相关类型的初始化，比如，`new String[]`只会直接触发`String[]`类的初始化，也就是触发对类`[Ljava.lang.String`的初始化，而直接不会触发String类的初始化）时，如果类没有进行过初始化，则需要先对其进行初始化。生成这四条指令的最常见的Java代码场景是：1)使用new关键字实例化对象的时候；2)读取或设置一个类的静态字段（被final修饰，已在编译器把结果放入常量池的静态字段除外）的时候；3)调用一个类的静态方法的时候。
* 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
* 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
* 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
*  当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。

注意，对于这五种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有且只有”，这五种场景中的行为称为对一个类进行 主动引用。除此之外，所有引用类的方式，都不会触发初始化，称为 被动引用。

特别需要指出的是，类的实例化与类的初始化是两个完全不同的概念：类的实例化是指创建一个类的实例(对象)的过程；类的初始化是指为类中各个类成员(被static修饰的成员变量)赋初始值的过程，是类生命周期中的一个阶段。

## 2. 类装载器

类装载器就是寻找类的class文件并构造出类在JVM内部表示对象的组件。类装载器负责将.class文件加载到内存中，并为之生成对应的Class对象。在Java中，类装载器把一个类装入JVM中，需要经过以下步骤：

* 1.加载：查找和导入Class文件。通过类的全限定名和ClassLoader加载类，主要是将指定的.class文件加载至JVM。当类被加载以后，在JVM内部就以“类的全限定名+ClassLoader实例ID”来标明类。
* 2.链接：执行验证（检查Class文件数据的正确性）、准备（给类的静态变量分配存储空间）和解析（将符号引用转换为直接引用）步骤，其中解析步骤是可选择的。
* 3.初始化：对类的静态变量、静态代码执行初始化工作。

注意，在内存中，ClassLoader实例和类的实例都位于堆中，它们的类信息都位于方法区。

类装载工作由根装载器、ClassLoader及其子类负责。**根装载器（启动类装载器，Bootstrap ClassLoader）**是虚拟机自身的一部分；ClassLoader类是一个抽象类，位于java.lang包中，**ClassLoader及其子类**由Java实现，独立于虚拟机外部。**JVM在运行时会产生3个类装载器：根装载器（启动类装载器，Bootstrap ClassLoader）、ExtClassLoader（扩展类装载器）和AppClassLoader（应用类装载器）。这三个类装载器之间存在父子层级关系，即根装载器是ExtClassLoader的父装载器，ExtClassLoader是AppClassLoader的父装载器。**

* 根装载器/启动类装载器（BootStrap Class Loader）：负责加载rt.jar文件中所有的Java类，即Java的核心类都是由该ClassLoader加载。在Sun JDK中，这个类装载器是由C++实现的，并且在Java语言中无法获得它的引用。此类装载器负责将存放在 `<JAVA_HOME>\lib` 目录中的，或者被 `-Xbootclasspath `参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在lib 目录中也不会被加载）类库加载到虚拟机内存中。 
* 扩展类装载器（Extension Class Loader）：负责加载一些扩展功能的jar包。ExtClassLoader是ClassLoader的子类，ExtClassLoader负责装载JRE扩展目录ext中的jar包。它负责将`<Java_Home>/lib/ext`或者被 java.ext.dir系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类装载器。
* 应用类装载器（Application Class Loader）：负责加载启动参数中指定的Classpath中的jar包及目录，通常我们自己写的Java类也是由该ClassLoader加载。在Sun JDK中应用类装载器的名字叫AppClassLoader。AppClassLoader都是ClassLoader的子类，AppClassLoader负责装载Classpath路径下的类包。如果应用程序中没有自定义过自己的类装载器，一般情况下这个就是程序中默认的类装载器。
* 用户自定义类装载器（User Defined Class Loader）：这类装载器的父装载器是应用类装载器。由用户自定义类的加载规则，可以手动控制加载过程中的步骤。

类加载采用了cache机制，如果cache中保存了这个class就直接返回它，如果没有才从文件中读取和转换成class，并存入cache，这就是为什么修改了class，但是必须重新启动JVM才能生效，并且类只加载一次的原因。

## 3. 类与类装载器

类装载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类装载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类装载器都拥有一个独立的类名称空间。也就是说，比较两个类是否“相等”，只有在这两个类是由同一个类装载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类装载器不同，那这两个类就必定不相等。

这里所指的相等，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。

## 4. 双亲委托模型

JVM装载类时采取“双亲委托模型”，也称为“全盘负责委托机制”。

* “委托机制”是指先委托父装载器寻找目标类，只有在找不到的情况下才从自己的类路径中查找并装载目标类。”委托机制”实际上是基于安全性引入的。因为首先由根装载器来装载，只有在找不到类时才从自己的类路径中（JRE扩展目录ext或Classpath路径）查找并装载目标类，这样避免了有人编写了一个恶意的基础类(如java.lang.String)并装载到JVM中所带来的可怕后果。
* ”全盘负责”是指当一个ClassLoader装载一个类时，除非显示地使用另一个ClassLoader，该类所依赖及引用的类也由这个ClassLoader载入；

经典的java.lang.NoSuchMethodError错误基本上都是由于JVM的“全盘负责委托机制”引发的问题，通常是因为在类路径下放置了多个不同版本的类库（jar），JVM装载类恰好装载的jar里的类没有相应方法。

## 5. 不遵守双亲委托模型的场景

双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前--即JDK1.2发布之前。由于双亲委派模型是在JDK1.2之后才被引入的，而类加载器和抽象类java.lang.ClassLoader则是JDK1.0时候就已经存在，面对已经存在 的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2之后的java.lang.ClassLoader添加了一个新的proceted方法findClass()，在此之前，用户去继承java.lang.ClassLoader的唯一目的就是重写loadClass()方法，因为虚拟在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass()。**JDK1.2之后已不再提倡用户再去覆盖java.lang.ClassLoader类中的loadClass()方法，应当把自己的类加载逻辑写到findClass()方法中，在loadClass()方法的逻辑里，如果父类加载器加载失败，则会调用自己的findClass()方法来完成加载**，这样就可以保证新写出来的类加载器是符合双亲委派模型的。

双亲委派模型的第二次“被破坏”是这个模型自身的缺陷所导致的，双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的加载器进行加载)，基础类之所以被称为“基础”，是因为它们总是作为被调用代码调用的API。但是，如果基础类又要调用用户的代码，那该怎么办呢。这并非是不可能的事情，一个典型的例子便是JNDI服务，它的代码由启动类加载器去加载(在JDK1.3时放进rt.jar)，但JNDI的目的就是对资源进行集中管理和查找，它需要调用独立厂商实现部部署在应用程序的classpath下的JNDI接口提供者(SPI, Service Provider Interface)的代码，但启动类加载器不可能“认识”这些代码，该怎么办？为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：**通过线程上下文件类加载器(Thread Context ClassLoader)来解决SPI加载碰到的问题。**这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。有了线程上下文类加载器，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI,JDBC,JCE,JAXB和JBI等。

双亲委派模型的第三次“被破坏”是由于用户对程序动态性追求而导致的。这里所说的“动态性”指的是当前一些非常热门的名词：代码热替换（HotSwap）、模块热部署(Hot Deployment)等。即希望应用程序能像计算机的外设一样，接上鼠标、键盘，不用重启就能立即使用，鼠标出了问题或需要升级就换个鼠标，不用停机或重启。当前业界“事实上”的**Java模块化标准是OSGi，而OSGi实现代码模块化热部署的关键则是它自定义的类机载器的实现。**每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当受到类加载请求时，OSGi将按照下面的顺序进行类搜索：

* 1）将java.＊开头的类委派给父类加载器加载。
* 2）否则，将委派列表名单内的类委派给父类加载器加载。
* 3）否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。
* 4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。
* 5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。
* 6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。
* 7）否则，类加载器失败。
