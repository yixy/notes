# Rust-所有权

rust没有GC，也没有运行时。rust使用所有权系统来管理内存，内存管理工作都在编译期解决。

## 1 内存所有权规则

* 所有权的基本规则：每个值同时都唯一对应一个变量，这个变量是该值的所有者。当所有者超出作用域（scope）时，该值会被删除（drop）。

## 2 变量赋值的内存分配

将值赋给变量时将发生copy或move。

stack上的内存分配：（赋值时拷贝了一个副本）

* stack上的数据-拷贝copy：将stack上的内容拷贝一份，这种情况下深拷贝deep copy和浅拷贝shallow copy是没有区别的。在离开作用域时，两个值才被drop。

heap上的内存分配：（赋值时所有权移交）

* heap上的数据-移交move：类似浅拷贝shallow copy（拷贝stack上内容，包含指向heap的指针，但不拷贝heap上的内容），但是原变量stack上的内容会被drop。注意，此时原变量离开作用域时不会再次被drop了。

> 编译器会对已被移交（move）所有权的变量访问操作进行检查，若有这种情况编译器会直接报错。如果想要针对heap变量进行深拷贝，在rust中可以使用clone方法。

```rust
let foo = String::from("sdfsfd");
let bar = foo.clone();
//let bar=foo; //若采用直接赋值方式，此时所有权移交，后续对foo的访问会编译报错
println!("==={}", foo);
println!("==={}", bar);
```

**注意，任何简单标量的组合类型都可以是Copy的，任何需要分配内存或某种资源的类型都不是Copy的。**

## 3 所有权与函数（借用）、引用、切片

**在语义上，与值赋给变量是类似，将值传给函数以及函数在返回值过程中也将发生copy或move。**

* 借用（borrow）： **可以通过使用引用（Reference，允许引用某些值而不取得其所有权），让函数使用某个值，但不获得其所有权，这种方式被称为借用。** 引用的技术实现本质上就是指针的copy（值传递）

rust为了避免竞争条件，对引用设定了如下规则：

* 作用域内只能有一个可变引用：在特定作用域中，对某一块数据，只能存在一个可变的引用。
* 作用域内可以有多个不可变引用，但它们与可变引用互斥：不可以同时拥有一个可变引用和一个不可变引用。
* 编译器保证在引用离开作用域之前数据不会离开作用域。

**不持有所有权的切片数据类型slice本质上也是引用。**

