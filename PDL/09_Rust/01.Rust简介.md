# Rust简介

## 1. Rust特点

AOT

* 运行速度快
* 需要内存安全
* 更好的运用多处理器

## 2. Rust安装

The two main ways to install Rust are:

* rust: The Native installation, recommended if you only use rust for running or installing software made with Rust
* rustup: The Rustup installation, recommended if you intend to program anything in Rust

```bash
#toolchain
pacman -S rustup
#compiler
rustup default stable

#更新
rustup update
#卸载
rustup self uninstall
rustup doc

rustc --version
```

## 3. Cargo: 构建系统和包管理工具

rust中代码包被称为crate。

```bash
cargo new project_name

#build to debug
cargo build
#build before run if changed 
cargo run
cargo check

#build to target, slow..
cargo build --release
```

## 4. 数据类型

rust是强类型语言，编译期就明确所有变量的类型。

一个标量类型代表一个值，**rust的基础标量类型**包括整数、浮点、布尔、字符等类型。

整数默认类型是i32，浮点数默认类型是f64。字符类型是Unicode标量值，可以表示比ASCII多得多的字符内容。

**复合类型**可以将多个值放在一个类型里，rust的基础复合类型包括Tuple和数组。

tup的长度是固定的，其中各元素类型可不同。

数组的长度是固定的，其中各个元素类型必须相同。数组在stack上分配。

vector、String、Hashmap等的长度是可变的，在堆上分配。

## 5. 变量和可变性

使用**let**声明不可变变量，增加**mut**关键字可以声明可变变量。rust变量支持类型推断，注意，如果有多个可能类型则需显式指定类型。

rust中变量具有**shadowing**特性，即可以使用相同标识符声明新的变量，新变量会shadow之前声明的同名变量，新变量可以具有不同的变量。

使用**const**声明常量，常量必须明确类型（不支持类型推断）。

## 6. 表达式、语句和函数

表达式以分号结尾。**rust中表达式有返回值，但语句没有返回值。** 这一点和C语言不一样。

注意，**花括号括起来的代码块blockcode也是一个表达式，其值为最后一个表达式的值，如果其中没有表达式则为空tup。**

函数调用、函数定义、if条件等都是表达式。

函数体由一系列语句组成，可选的由一个表达式结束。函数使用函数体中最后一个表达式作为返回值，除非使用return关键字提前指定。

## 7 所有权

rust没有GC，也没有运行时。rust使用所有权系统来管理内存，内存管理工作都在编译期解决。

### 7.1 内存所有权规则

* 所有权的基本规则：每个值同时都唯一对应一个变量，这个变量是该值的所有者。当所有者超出作用域（scope）时，该值会被删除（drop）。

### 7.2 变量赋值的内存分配

将值赋给变量时将发生copy或move。

stack上的内存分配：（赋值时拷贝了一个副本）

* stack上的数据-拷贝copy：将stack上的内容拷贝一份，这种情况下深拷贝deep copy和浅拷贝shallow copy是没有区别的。在离开作用域时，两个值才被drop。

heap上的内存分配：（赋值时所有权移交）

* heap上的数据-移交move：类似浅拷贝shallow copy（拷贝stack上内容，包含指向heap的指针，但不拷贝heap上的内容），但是原变量stack上的内容会被drop。注意，此时原变量离开作用域时不会再次被drop了。

> 如果想要针对heap变量进行深拷贝，在rust中可以使用clone方法。

**注意，任何简单标量的组合类型都可以是Copy的，任何需要分配内存或某种资源的类型都不是Copy的。**

### 7.3 所有权与函数（借用）、引用、切片

**在语义上，与值赋给变量是类似，将值传给函数以及函数在返回值过程中也将发生copy或move。**

* 借用（borrow）： **可以通过使用引用（Reference，允许引用某些值而不取得其所有权），让函数使用某个值，但不获得其所有权，这种方式被称为借用。** 引用的技术实现本质上就是指针的copy（值传递）

rust为了避免竞争条件，对引用设定了如下规则：

* 作用域内只能有一个可变引用：在特定作用域中，对某一块数据，只能存在一个可变的引用。
* 作用域内可以有多个不可变引用，但它们与可变引用互斥：不可以同时拥有一个可变引用和一个不可变引用。
* 编译器保证在引用离开作用域之前数据不会离开作用域。

**不持有所有权的切片数据类型slice本质上也是引用。**

## 8. 结构体

User 结构体的定义中，我们使用了自身拥有所有权的 String 类型而不是 &str 字符串 slice 类型。这是一个有意而为之的选择，因为我们想要这个结构体拥有它所有的数据，为此只要整个结构体是有效的话其数据也是有效的。可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上 生命周期（lifetimes）

```rust
    //create struct
    struct User {
        active: bool,
        username: String,
        email: String,
        sign_in_count: u64,
    }
    let user1 = User {
        active: true,
        username: String::from("Tom"),
        email: String::from("tom@tom.com"),
        sign_in_count: 1,
    };
    //create struct from another struct
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };

    //tuple struct
    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);

    //unit-like struct
    struct AlwaysEqual;

    //

```

每个结构体都允许拥有多个 impl 块。用于声明结构体方法，或者是关联函数。

```rust
    impl User {
        //method of struct
        fn introduce(&self) {
            println!("my name is {}", self.username)
        }
        //assoiciated fuctions
        fn example() -> Self {
            Self {
                active: true,
                username: String::from("Jerry"),
                email: String::from("jerry@jerry.com"),
                sign_in_count: 2,
            }
        }
    }
```

## 9. 枚举和模式匹配

### 9.1 枚举

rust的枚举中可以定义成员和方法。

```rust
    enum IpAddr {
        V4(String),
        V6(String),
    }
    let home = IpAddr::V4(String::from("127.0.0.1"));
    let loopback = IpAddr::V6(String::from("::1"));

    //可以使用 impl 来为枚举定义方法。
    impl IpAddr {
        fn call(&self) {
            //......
        }
    }
```

Rust 并没有空值，不过它确实拥有一个可以编码存在或不存在概念的枚举。这个枚举是 Option<T>，而且它定义于标准库中，如下:

```rust
    enum Option<T> {
        None,
        Some(T),
    }
    let some_number = Some(5);
    let some_char = Some('e');
    let absent_number: Option<i32> = None;
```

空值的问题在于当你尝试像一个非空值那样使用一个空值，会出现某种形式的错误。因为空和非空的属性无处不在，非常容易出现这类错误。

Option<T> 枚举是如此有用以至于它甚至被包含在了 prelude 之中，不需要将其显式引入作用域。另外，它的成员也是如此，可以不需要 Option:: 前缀来直接使用 Some 和 None。即便如此 Option<T> 也仍是常规的枚举，Some(T) 和 None 仍是 Option<T> 的成员。

Option<T> 和 T（这里 T 可以是任何类型）是不同的类型，编译器不允许像一个肯定有效的值那样使用 Option<T>。例如，尝试将 Option<i8> 与 i8 相加将导致编译器报错。换句话说，在对 Option<T> 进行运算之前必须将其转换为 T。通常这能帮助我们捕获到空值最常见的问题之一：假设某值不为空但实际上为空的情况。

### 9.2 match模式匹配

当 match 表达式执行时，它将结果值按顺序与每一个分支的模式相比较。如果模式匹配了这个值，这个模式相关联的代码将被执行。如果模式并不匹配这个值，将继续执行下一个分支。每个分支相关联的代码是一个表达式，而表达式的结果值将作为整个 match 表达式的返回值。

匹配分支的另一个有用的功能是可以绑定匹配的模式的部分值。这也就是如何从枚举成员中提取值的。

```rust
    #[derive(Debug)] //这样可以立刻看到州的名称
    enum UsState {
        Alabama,
        Alaska,
        // --snip--
    }
    enum Coin {
        Penny,
        Nickel,
        Dime,
        Quarter(UsState),
    }
    fn value_in_cents(coin: Coin) -> u8 {
        match coin {
            Coin::Penny => 1,
            Coin::Nickel => 5,
            Coin::Dime => 10,
            Coin::Quarter(state) => {
                println!("State quarter from {:?}!", state);
                25
            }
        }
    }
```

匹配是穷尽的，可以使用通配模式和 _ 占位符。当我们不想使用通配模式获取的值时，请使用 _ ，这是一个特殊的模式，可以匹配任意值而不绑定到该值。这告诉 Rust 我们不会使用这个值，所以 Rust 也不会警告我们存在未使用的变量。

```rust
    let dice_roll = 9;
    match dice_roll {
        3 => three(),
        7 => seven(),
        other => do_other_thing(other),
    }

    let dice_roll = 9;
    match dice_roll {
        3 => three(),
        7 => seven(),
        _ => do_other_thing(),
    }
```

if let 是 match 的一个语法糖，它当值匹配某一模式时执行代码而忽略所有其他值。

```rust
    let config_max = Some(3u8);
    match config_max {
        Some(max) => println!("The maximum is configured to be {}", max),
        _ => (),
    }

    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!("The maximum is configured to be {}", max);
    }
```

## 10. package crate module path

* 包（Packages）：Cargo 的一个功能，它允许你构建、测试和分享 crate。package是提供一系列功能的一个或者多个 crate。一个包会包含一个 Cargo.toml 文件，阐述如何去构建这些 crate。
* Crates ：一个模块module的树形结构，它可以是binary或library。

包中可以包含至多一个库 crate(library crate)。包中可以包含任意多个二进制 crate(binary crate)，但是必须至少包含一个 crate（无论是库的还是二进制的）。

Cargo 遵循一个约定：src∕main.rs 就是一个与包同名的二进制 crate 的 crate 根。同样的，Cargo 知道如果包目录中包含 src∕lib.rs，则包带有与其同名的库 crate，且 src∕lib.rs 是 crate 根。通过将文件放在 src∕bin 目录下，一个包可以拥有多个二进制 crate：每个 src∕bin 下的文件都会被编译成一个独立的二进制 crate。

> crate root 是一个源文件，Rust 编译器以它为起始点，并构成你的 crate 的根模块。

* 模块（Modules）和 use：在crate root中可以通过mod关键字声明module，来控制作用域和路径的私有性。使用use关键字可以将module引入当前作用域，注意此时仍遵守私有性原则，可以使用pub use使相关条目使外部代码可以将其引入它们的作用域。

模块可以嵌套定义，编译器会在以父模块命名的目录中寻找子模块代码。一个模块里的代码默认对其父模块私有。为了使一个模块公用，应当在声明时使用pub mod替代mod。为了使一个公用模块内部的成员公用，应当在声明前使用pub。注意，pub声明的枚举enum中变体默认也是公共的，这与pub声明的struct中字段默认是私有的不同。

父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用他们父模块中的项。这是因为子模块封装并隐藏了他们的实现详情，但是子模块可以看到他们定义的上下文。

在一个作用域内，use关键字创建了一个成员的快捷方式，用来减少长路径的重复。在任何可以引用crate :: garden::vegetables::Asparagus的作用域，你可以通过 use crate::garden::vegetables::Asparag建一个快捷方式，然后你就可以在作用域中只写Asparagus来使用该类型。

使用use关键字时，习惯性做法通常是函数指定到父级（将函数的父级模块引入作用域），struct、enum和其他指定到本身（指定完整路径）。对于同名条目可以使用as关键字定义别名。

* 路径（path）：通过路径命名访问module中的项，例如结构体、函数、枚举或模块。

绝对路径（absolute path）是以 crate 根（root）开头的全路径；对于外部 crate 的代码，是以crate 名开头的绝对路径，对于对于当前 crate 的代码，则以字面值 crate 开头。

相对路径（relative path）从当前模块开始，以 self、super 或当前模块的标识符开头。

> 最佳实践：模块树应该定义在 src∕lib.rs 中。这样通过以包名开头的路径，公有项就可以在二进制 crate 中使用。二进制 crate 就完全变成了同其它外部 crate 一样的库 crate 的用户：它只能使用公有 API。这有助于你设计一个好的 API；你不仅仅是作者，也是用户！在第十二章我们会通过一个同时包含二进制crate 和库 crate 的命令行程序来展示这些包组织上的实践

## 11 常见集合（heap上分配内存）

### 11.1 vector

当 vector 被丢弃时，所有其内容也会被丢弃，这意味着这里它包含的整数将被清理。借用检查器确保了任何 vector 中内容的引用仅在 vector 本身有效时才可用。

```rust
    let v: Vec<i32> = Vec::new();
    //使用宏
    let v = vec![1, 2, 3];

    //更新vector
    let mut v = Vec::new();
    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);

    //当引用一个不存在的元素时 Rust 会造成 panic
    let v = vec![1, 2, 3, 4, 5];
    let third: &i32 = &v[2];
    println!("The third element is {third}");
    //当 get 方法被传递了一个数组外的索引时，它不会 panic 而是返回 None。接着你的代码可以有处理 Some(&element) 或 None 的逻辑。
    let third: Option<&i32> = v.get(2);
    match third {
        Some(third) => println!("The third element is {third}"),
        None => println!("There is no third element."),
    }

    //当需要在 vector 中储存不同类型值时，我们可以定义并使用一个枚举
     enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }
    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];
    //如果在编写程序时不能确切无遗地知道运行时会储存进 vector 的所有类型，枚举技术就行不通了。相反，你可以使用 trait 对象,这将这后面介绍。
```

### 11.2 字符串

Rust 的核心语言中只有一种字符串类型：字符喘切片。字符串字面值本质上也是字符串切片&str。

很多 Vec 可用的操作在 String 中同样可用，事实上 String 被实现为一个带有一些额外保证、限制和功能的字节 vector 的封装。String 是一个 Vec<u8> 的封装。

String 的大小可以增加，其内容也可以改变，就像可以放入更多数据来改变 Vec 的内容一样。另外，可以方便的使用 + 运算符或 format! 宏来拼接 String 值。


```rust
    //附加字符或字符串
    let mut s = String::from("foo");
    s.push('.);
    s.push_str("bar");

    //因为s2是字符串切片，所以所有权不转移
    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2 is {s2}");

    //s1所有权发生了转移
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");
    let s = s1 + "-" + &s2 + "-" + &s3;

    //宏 format! 生成的代码使用引用所以不会获取任何参数的所有权。
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");
    let s = format!("{s1}-{s2}-{s3}");
}

```

注意，Rust 的字符串不支持索引。

```rust
for c in "Зд".chars() {
    println!("{c}");
}

for b in "Зд".bytes() {
    println!("{b}");
}
```

### 11.3 hashmap

在这三个常用集合中，HashMap 是最不常用的，所以并没有被 prelude 自动引用。标准库中对 HashMap 的支持也相对较少，例如，并没有内建的构建宏。类似于 vector，哈希 map 是同质的：所有的键必须是相同类型，值也必须都是相同类型。

对于像 i32 这样的实现了 Copy trait 的类型，其值可以拷贝进哈希 map。对于像 String 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者。

```rust
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    //替换以特定键储存的值
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
    //只在键没有对应值时插入键值对
    scores.entry(String::from("Yellow")).or_insert(50);
    scores.entry(String::from("Blue")).or_insert(50);

    let team_name = String::from("Blue");
    let score = scores.get(&team_name).copied().unwrap_or(0);
```

## 12 错误处理

Rust 将错误分为两大类：可恢复的（recoverable）和 不可恢复的（unrecoverable）错误。对于一个可恢复的错误，比如文件未找到的错误，我们很可能只想向用户报告问题并重试操作。

Result<T, E> 类型，用于处理可恢复的错误，还有 panic! 宏，在程序遇到不可恢复的错误时停止执行。本章首先介绍 panic! 调用，接着会讲到如何返回 Result<T, E>。
