# Rust简介

## 1. Rust特点

AOT

* 运行速度快
* 需要内存安全
* 更好的运用多处理器

## 2. Rust安装

The two main ways to install Rust are:

* rust: The Native installation, recommended if you only use rust for running or installing software made with Rust
* rustup: The Rustup installation, recommended if you intend to program anything in Rust

```bash
#toolchain
pacman -S rustup
#compiler
rustup default stable

#更新
rustup update
#卸载
rustup self uninstall
rustup doc

rustc --version
```

## 3. Cargo: 构建系统和包管理工具

第三方代码包被称为crate。

```bash
cargo new project_name

#build to debug
cargo build
#build before run if changed 
cargo run
cargo check

#build to target, slow..
cargo build --release
```

## 4. 数据类型

rust是强类型语言，编译期就明确所有变量的类型。

一个标量类型代表一个值，**rust的基础标量类型**包括整数、浮点、布尔、字符等类型。

整数默认类型是i32，浮点数默认类型是f64。字符类型是Unicode标量值，可以表示比ASCII多得多的字符内容。

**复合类型**可以将多个值放在一个类型里，rust的基础复合类型包括Tuple和数组。

tup的长度是固定的，其中各元素类型可不同。

数组的长度是固定的，其中各个元素类型必须相同。数组在stack上分配。

vector的长度是可变的，在堆上分配。

## 5. 变量和可变性

使用**let**声明不可变变量，增加**mut**关键字可以声明可变变量。rust变量支持类型推断，注意，如果有多个可能类型则需显式指定类型。

rust中变量具有**shadowing**特性，即可以使用相同标识符声明新的变量，新变量会shadow之前声明的同名变量，新变量可以具有不同的变量。

使用**const**声明常量，常量必须明确类型（不支持类型推断）。

## 6. 表达式、语句和函数

**rust中表达式有返回值，但语句没有返回值。** 这一点和C语言不一样。

注意，**花括号括起来的代码块blockcode也是一个表达式，其值为最后一个表达式的值，如果其中没有表达式则为空tup。**

函数调用、函数定义、if语句、等都是表达式。

函数体由一系列语句组成，可选的由一个表达式结束。函数使用函数体中最后一个表达式作为返回值，除非使用return关键字提前指定。

## 7 所有权

rust没有GC，也没有运行时。rust使用所有权系统来管理内存，内存管理工作都在编译期解决。

### 7.1 内存所有权规则

* 所有权的基本规则：每个值同时都唯一对应一个变量，这个变量是该值的所有者。当所有者超出作用域（scope）时，该值会被删除（drop）。

### 7.2 变量赋值的内存分配

将值赋给变量时将发生copy或move。

stack上的内存分配：（赋值时拷贝了一个副本）

* stack上的数据-拷贝copy：将stack上的内容拷贝一份，这种情况下深拷贝deep copy和浅拷贝shallow copy是没有区别的。在离开作用域时，两个值才被drop。

heap上的内存分配：（赋值时所有权移交）

* heap上的数据-移交move：类似浅拷贝shallow copy（拷贝stack上内容，包含指向heap的指针，但不拷贝heap上的内容），但是原变量stack上的内容会被drop。注意，此时原变量离开作用域时不会再次被drop了。

> 如果想要针对heap变量进行深拷贝，在rust中可以使用clone方法。

**注意，任何简单标量的组合类型都可以是Copy的，任何需要分配内存或某种资源的类型都不是Copy的。**

### 7.3 所有权与函数、引用、切片

**在语义上，与值赋给变量是类似，将值传给函数以及函数在返回值过程中也将发生copy或move。**

* 借用（borrow）： **可以通过使用引用（Reference，允许引用某些值而不取得其所有权），让函数使用某个值，但不获得其所有权。** 引用的技术实现本质上就是指针的copy（值传递）

rust为了避免竞争条件，对引用设定了如下规则：

* 在特定作用域中，对某一块数据，只能存在一个可变的引用。
* 不可以同时拥有一个可变引用和一个不可变引用。
* 编译器保证在引用离开作用域之前数据不会离开作用域。

**不持有所有权的切片数据类型slice本质上也是引用。**


