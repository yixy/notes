# 并发处理-传统模式:Callback&Future&Quere #

首先，我们将检查基本的“异步”模式：Callback&Future&Quere，它们在其他一些语言中用作并发原语。

An asynchronous API returns to the caller before its result is ready.

## 1  ASYNCHRONOUS CALLBACK ##

异步回调存在代码耦合度高，逻辑理解困难，难于进行调试和错误处理等缺点。通常情况下，这不是我们编写 Go 的方式。


```go
// Fetch immediately returns, then fetches the item and
 // invokes f in a goroutine when the item is available.
 // If the item does not exist,
 // Fetch invokes f on the zero Item.
func Fetch(name string, f func(Item)) { 
    go func() {
        [...]
        f(item) 
    }()
}
```

## 2 ASYNCHRONOUS API: Future ##

在 Future 模式中，函数不返回结果，而是返回一个代理对象，允许调用者在稍后的某个时间等待结果。在具有内置Future模式支持的语言中，它也通常被称为“async 和 await”。

> 在计算机科学中，future、promise、delay和deferred是指用于在某些并发编程语言中同步程序执行的构造。由于某些计算（或者网络请求）尚未结束，我们需要一个对象来代理这个未知的结果，于是就有了上述这些构造（future、promise等）。术语future、promise、delay和deferred通常可以互换使用。

Go中的**Future可以使用单元素的buffer channel来模拟实现**。


```go
 // Fetch immediately returns a channel, then fetches
 // the requested item and sends it on the channel.
 // If the item does not exist,
 // Fetch closes the channel without sending.
func Fetch(name string) <-chan Item {
    c := make(chan Item, 1)
    go func() {
        [...]
        c <- item
    }()
    return c
}
```

这并不完全是传统的 Future 模式，因为我们只能从通道接收一次值，但通道模式似乎比下面基于函数的替代方案更常见。

```go
func Fetch(name string) (func() Item) { 
    item := new(Item)
    ready := make(chan struct{})
    go func(){
        [...]
    }
    return func() Item {
        <-ready
        return *item
    }
}
```

注意，Future API的调用方式，如果过早地检索结果，程序将按顺序执行而不是并发执行。

```go
//正确的调用方式
a := Fetch("a") 
b := Fetch("b") 
consume(<-a, <-b)

//错误的调用方式，如果过早地检索结果，程序将按顺序执行而不是并发执行。
a := <-Fetch("a") 
b := <-Fetch("b") 
consume(a, b)
```

## 3 ASYNCHRONOUS API: Queue ##

生产者-消费者队列也返回一个通道，但该通道接收任意数量的结果并且通常是无缓冲的。

```go
 PRODUCER–CONSUMER QUEUE: API
// Glob finds all items with names matching pattern
// and sends them on the returned channel.
// It closes the channel when all items have been sent. 
func Glob(pattern string) <-chan Item {
     c := make(chan Item)
     go func() {
          defer close(c)
          for [...] {
               [...]
               c <- item 
          }
     }()
     return c
}
```

调用方是一个range-loop而不是单个接收操作。

```go
for item := range Glob("[ab]*") { 
    [...]
}
```