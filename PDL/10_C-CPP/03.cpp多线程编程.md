# cpp多线程编程

应该尽可能减少使用跨线程的对象，而使用流水线，生产者消费者，任务队列这些有规律的机制，最低限度地共享数据。这是最好的多线程编程建议。

C++建议：避免使用指针。

## 1 线程安全的对象生命周期管理

编写线程安全的类不是难事,用同步原语(synchronization primitives)保护内部状态即可。但是对象的生与死不能由对象自身拥有的 mutex(互斥器)来保护。如何避免对象析构时可能存在的 race condition(竞态条件)是 C++ 多线程编程面临的基本问题,可以借助智能指针完美解决。这也是实现线程安全的 Observer 模式的必备技术。

### 1.1 对象构造的安全

对象构造要做到线程安全,唯一的要求是在构造期间不要泄露 this 指针,即：

* 不要在构造函数中注册任何回调; 
* 也不要在构造函数中把 this 传给跨线程的对象; 
* 即便在构造函数的最后一行也不行。

之所以这样规定,是因为在构造函数执行期间对象还没有完成初始化,如果 this 被泄露(escape)给了其他对象(其自身创建的子对象除外) ,那么别的线程有可能访问这个半成品对象,这会造成难以预料的后果。即使构造函数的最后一行也不要泄露 this，因为对应类有可能是个基类，基类先于派生类构造，执行完构造函数的最后一行代码还会继续执行派生类的构造函数, 这时 most-derived class 的对象还处于构造中,仍然不安全。

对象构造的正确方法：二段式构造(构造函数 +initialize()，另外定义一个函数,在构造之后执行回调函数的注册工作），这虽然不符合 C++ 教条,但是多线程下别无选择。另外,既然允许二段式构造,那么构造函数不必主动抛异常,调用方靠 initialize() 的返回值来判断对象是否构造成功,这能简化错误处理。

### 1.2 使用线程同步原语

一个使用mutex进行多线程临界区资源访问的例子。

***避免死锁***

一个函数如果要锁住相同类型的多个对象,为了保证始终按相同的顺序加锁,我们可以比较 mutex 对象的地址,始终先加锁地址较小的 mutex。

### 1.3 作为数据成员的 mutex 不能保护析构

在析构函数中使用类成员的mutex并不能保证线程安全。因为如果类对象是动态创建的并通过指针来访问，那么对象销毁存在 race condition，此时如果析构函数会把 mutex 销毁，那么另一个线程即使用了mutex就会存在问题，有可能永远阻塞下去，有可能进入“临界区” ,然后 core dump，或者发生其他更糟糕的情况。

一个典型的例子如下：



**使用智能指针**

以上的竞争条件似乎可以通过加锁来解决，但在哪儿加锁，谁持有这些互斥锁，又似乎不是那么显而易见的。判断对象的指针是否为空并不能解决类似的竞争条件。一个想法是，其他线程保存的不是目标对象的原始指针，而是别的什么东西，能够分辨目标对象是否存活。

#### 裸指针（raw pointer）：指向对象的原始指针（raw pointer）是坏的，尤其是暴露给别的线程时。

* 传统的指针，需要手动管理内存。
* 不具备智能指针的自动内存管理和安全性。

> 孟岩在《址圾收集机制批判》中一针见血地点出智能指针的优势：“C++利用智能指针达成的效果是：一旦某对象不再被引用，系统刻不容缓，立刻回收内存。这通常发生在关键任务完成后的清理 Cclean up） 时期，不会影响关键任务的实时性，同时，内存里所有的对象都是有用的，绝对没有垃圾空占内存。

#### std::shared_ptr：引用计数型智能指针

shared_ptr 是引用计数型智能指针，被纳入C++11标准库。shared_ptr<T>是一个类模板 (class template)，它只有一个类型参数，使用起来很方便。引用计数是自资源管理的常用手法，当引用计数降为0时，对象（资源）即被销毀。weak_ptr 也是一个引用计数型智能指针，但是它不增加对象的引用次数，即弱(weak）引用。

* 允许多个 std::shared_ptr 共享同一份资源。
* 使用引用计数来跟踪资源的所有权。
* 当最后一个 std::shared_ptr 被销毁时，资源才会被释放。

注意：

* shared_ptr/weak_ptr 的“计数”在主流平台上是原子操作，没有用锁，性能不俗。
* shared_ptr/weak_ptr 的线程安全级别与 sta:string 和 STL 容器一样。

#### std::weak_ptr：弱引用

* 用于解决 std::shared_ptr 的循环引用问题。
* 不影响引用计数。
* 使用 lock 成员函数获取 std::shared_ptr，如果对象已经被销毁，则返回一个空的 std::shared_ptr。提升lockO行为是线程安全的。

例如，A 类和 B 类相互持有对方的 std::shared_ptr，导致它们的引用计数永远不会降为零，因此它们的析构函数永远不会被调用，资源无法正确释放，形成了循环引用。解决方法是使用 std::weak_ptr 作为其中一个关联，因为 std::weak_ptr 不会增加引用计数，它只是观察 std::shared_ptr 所管理的对象是否还存在。如果对象还存在，可以通过 lock() 成员函数获得一个有效的 std::shared_ptr；如果对象已经被销毁，lock() 返回一个空的 std::shared_ptr。std::weak_ptr 指向的对象在被销毁的时机取决于它所观察的 std::shared_ptr 对象的生命周期。具体来说，当最后一个关联的 std::shared_ptr 对象被销毁时，std::weak_ptr 就无法再通过 lock() 获取有效的 std::shared_ptr，这时就说明被观察的对象已经被销毁。当 sharedPtr 被 reset() 后，对象的引用计数变为 0，导致对象被销毁，从而观察它的 std::weak_ptr 也就无法通过 lock() 获取有效的 std::shared_ptr。这时 weakPtr.lock() 返回一个空指针，表明被观察的对象已经被销毁。

#### std::unique_ptr

* 拥有独占所有权，不能被复制。
* 当 std::unique_ptr 被销毁时，它所管理的对象也会被销毁。
* 适用于独占资源的情况。

> 不再建议使用boost::scoped_ptr（类似于 std::unique_ptr。C++11 引入了 std::unique_ptr）
