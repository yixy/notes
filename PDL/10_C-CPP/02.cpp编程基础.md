# C++编程基础

## 1 类型与变量

C++中使用extern关键字声明变量，但注意如果在函数体外初始化extern变量，则该操作变成变量定义（函数体内初始化extern变量会编译报错）。

* 变量只能被定义一次，但是允许多次声明。

C++区分变量初始化和赋值。

* 初始化：创建变量时赋予一个初始值。
* 赋值：擦除当前对象的值，用一个新值代替。

使用=初始化时是拷贝初始化，不使用=是直接初始化，如()或{}。

```c++
    int a(1);
    int b{2};
    int c=3;
    std::vector<int> v1(10,1);
    std::vector<int> v2{10,1};
    std::vector<int> v3=v2;
    std::cout<<"hello,world!"<<std::endl;
    std::cout<<"a "<<a<<std::endl;           //a 1
    std::cout<<"b "<<b<<std::endl;           //b 2
    std::cout<<"c "<<c<<std::endl;           //c 3
    std::cout<<"v1 "<<v1.size()<<std::endl;           //v1 10
    std::cout<<"v2 "<<v2.size()<<std::endl;           //v2 2
    std::cout<<"v3 "<<v3.size()<<std::endl;           //v3 2
```

C++语言提供了几种不同的初始化方式，在大多数情况下这些初始化方式可以相互等价地使用，不过也并非一直如此。例外情况如下：

* 使用拷贝初始化时（即使用=初始化），只能提供一个初始值。
* 如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化。
* 如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。

使用{}进行初始化时，如果存在精度损失，则编译器会报错。

传统C++中列表初始化仅能用于普通数组和POD类型，C++11新标准将列表初始化应用于所有对象的初始化（但是内置类型习惯于用等号初始化，类类型习惯用构造函数圆括号显式初始化，vector、map和set等容器类习惯用列表初始化）

变量或对象的默认值：

* C不允许用户自定义默认值从而提高性能（增加函数调用的代价）。
* C++默认不做初始化从而提高性能，但是C++为类提供了构造函数让用户显式设置默认初始值（无论何时只要类的对象被创建就会执行构造函数，通过显式调用构造函数进行初始化被称为显式初始化，否则叫做隐式初始化）。有个例外是把全局变量初始化为零值仅仅在程序启动时会有成本，因此定义在任何函数之外的变量会被初始化为零值，而函数体内内置类型变量未被显示初始化时，其值是未定义的。

字符串字面值不是String类型

命名的强制类型转换。cast-name<type>(expression);

旧式的强制类型转换。在早期版本的C++语言中，显式地进行强制类型转换包舍两种形式：

```
type (expr);  //函数形式的强制类型转换
(type) expr;  //C语言风格的强制类型转换
```

强制类型转换干扰了正常的类型检查，因此强烈建议程序员避免使用强制类型转换。

## 2 运算符与表达式

表达式由一个或多个运算对象（operand）组成，对表达式求值将得到一个结果，字面值和变量是最简单单表达式（expression），其结果就是字面值和变量的值。把一个运算符（operator）和一个或多个运算对象组合起来可以生成较复杂的表达式。

&& || , ?:等4个运算符明确规定了先求左侧运算对象的值。

decltype


C++的表达式要不然是右值，要不然就是左值 。这两个名词是从C 语言继承过来的，原本是为了帮助记忆：左值可以位于賦值语句的左侧，右值则不能。在C++语言中，二者的区别就没那么简单了。一个左值表达式的求值结果是一个对象或者一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。此外，虽然某些表达式的求值结果是对象，但它们是右值而非左值。可以做一个简单的归纳：当一个对象被用作右值的时候，用的是对象的值（内容)：当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。

复合表达式（compound expression）是指含有两个或多个运算符的表达式。求复合表达式的值需要首先将运算符和运算对象合理地组合在一起，优先级与结合律决定了运算对象组合的方式。也就是说，它们决定了表达式中每个运算符对应的运算对象来自表达式的哪一部分。表达式中的括号无视上达规则，程序员可以使用括号将表达式的某个局部括起来使其得到优先运算。


求值顺序、优先级、结合律
运算对象的求值顺序与优先级和结合律无关，在一条形如f（)+g ()*b（)+j（)的表达式中：

* 优先级规定，g()的返回值和b()的返回值相乘。
* 结合律规定，f()的返回值先与g()和b()的乘积相加，所得结果再与j()的返回值相加。
* 对于这此函数的调用顺序没有明确规定。

## 3 引用与指针

引用类型（&）必须被初始化，初始化必须是对象，而不是字面值或表达式。引用即别名，初始化时是绑定操作（bind）而不是值拷贝。

指针本身也是对象，允许对指针赋值和拷贝，指针可以不被初始化。指针类型与其指向对象的类型必须匹配，否则操作可能会出现错误。C++11下尽量使用nullptr，而不使用NULL。

引用本身不是对象，所以不存在指向引用的指针。但是指针是对象，所以存在对指针的引用。

> 面对比较复杂的指针和引用声明语句，从右向左阅读有助于弄清楚它的真实含义。离变量名最近的符号对便量类型有最直接的影响。

## 头文件

头文件中通常只包含那些只能被定义一次的实体，如类、const、constexpr变量等，类通常被定义在头文件中，且头文件名与类名一致。

## vector

vector对象能够高效增长，与C或Java等不同，不建议一开始指定其元素个数，否则性能可能反而受到影响。如果元素固定，推荐使用数组，否则应该使用vector。

vector（以及string对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。

vector一般使用迭代器访问vector元素。实际上C++的标准容器都支持迭代器（string虽然不是容器也支持）。注意，使用了迭代器的循环体，都不要向迭代器所属的容器添加元素，这样会导致迭代器失效。
。

## 面向对象

在C++中class和struct关键字唯一的区别是，struct 和 class 的默认访问权限不太一样。类可以在它的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式。如果我们使用 struct 关键宇，则定义在第一个访问说明符之前的成员是public的：相反，如果我们使用 class关键字，则这些成员是 private 的。出于统一编程风格的考虑，当我们希望定义的类的所有成员是public 的时，使用struct;反之，如果希望成员是private 的，使用 class。

类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend)。如果类想把一个函数作为它的友元，只需要增加一条以friend 关键字开始的函数声明语句即可。

默认构造函数、委托构造函数

## 标准库

列出来标准库中的顺序容器，所有顺序容器都提供了快速顺序访问元素的能力。
但是，这些容器在以下方面都有不同的性能折中
•向容器添加或从容器中州除元素的代价
•非顺序访问容器中元素的代价
表

C++标准库中的顺序容器为程序员提供了控制元素存储和顺序访问元素的能力，包括vector，string，array，deque，list，forward_list。

* vector	可变大小数组，支持快速随机访问，在尾部插入或删除速度很快，非尾部插入或删除可能很慢。
* deque	双端队列，支持快速随机访问，在头尾插入或删除速度很快
* list	双向链表，只支持双向顺序访问，任何位置插入或删除速度都很快
* forward_list	单向链表，只支持单向顺序访问，在链表任何位置进行插入或删除速度都很快
* array	固定大小数组，支持快速随机访问，不能添加或删除元素
* string	类似vector，专门保存字符。

## 范型

## 智能指针

